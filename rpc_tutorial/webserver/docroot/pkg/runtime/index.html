<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>runtime - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
<script type="text/javascript">window.initFuncs = [];</script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
</script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">

<form method="GET" action="/search">
<div id="menu">
<a href="/doc/">Documents</a>
<a href="/pkg/">Packages</a>
<a href="/project/">The Project</a>
<a href="/help/">Help</a>
<a href="/blog/">Blog</a>

<a id="playgroundButton" href="http://play.golang.org/" title="Show Go Playground">Play</a>

<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
</div>
<div id="heading"><a href="/">The Go Programming Language</a></div>
</form>

</div></div>


<div id="playground" class="play">
	<div class="input"><textarea class="code">package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}</textarea></div>
	<div class="output"></div>
	<div class="buttons">
		<a class="run" title="Run this code [shift-enter]">Run</a>
		<a class="fmt" title="Format this code">Format</a>
		<a class="share" title="Share this code">Share</a>
	</div>
</div>


<div id="page" class="wide">
<div class="container">


  <h1>Package runtime</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "runtime"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package runtime contains operations that interact with Go&#39;s runtime system,
such as functions to control goroutines. It also includes the low-level type information
used by the reflect package; see reflect&#39;s documentation for the programmable
interface to the run-time type system.
</p>
<h3 id="hdr-Environment_Variables">Environment Variables</h3>
<p>
The following environment variables ($name or %name%, depending on the host
operating system) control the run-time behavior of Go programs. The meanings
and use may change from release to release.
</p>
<p>
The GOGC variable sets the initial garbage collection target percentage.
A collection is triggered when the ratio of freshly allocated data to live data
remaining after the previous collection reaches this percentage. The default
is GOGC=100. Setting GOGC=off disables the garbage collector entirely.
The runtime/debug package&#39;s SetGCPercent function allows changing this
percentage at run time. See <a href="http://golang.org/pkg/runtime/debug/#SetGCPercent">http://golang.org/pkg/runtime/debug/#SetGCPercent</a>.
</p>
<p>
The GODEBUG variable controls debug output from the runtime. GODEBUG value is
a comma-separated list of name=val pairs. Supported names are:
</p>
<pre>allocfreetrace: setting allocfreetrace=1 causes every allocation to be
profiled and a stack trace printed on each object&#39;s allocation and free.

efence: setting efence=1 causes the allocator to run in a mode
where each object is allocated on a unique page and addresses are
never recycled.

gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard
error at each collection, summarizing the amount of memory collected and the
length of the pause. Setting gctrace=2 emits the same summary but also
repeats each collection.

gcdead: setting gcdead=1 causes the garbage collector to clobber all stack slots
that it thinks are dead.

invalidptr: defaults to invalidptr=1, causing the garbage collector and stack
copier to crash the program if an invalid pointer value (for example, 1)
is found in a pointer-typed location. Setting invalidptr=0 disables this check.
This should only be used as a temporary workaround to diagnose buggy code.
The real fix is to not store integers in pointer-typed locations.

scheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit
detailed multiline info every X milliseconds, describing state of the scheduler,
processors, threads and goroutines.

schedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard
error every X milliseconds, summarizing the scheduler state.

scavenge: scavenge=1 enables debugging mode of heap scavenger.
</pre>
<p>
The GOMAXPROCS variable limits the number of operating system threads that
can execute user-level Go code simultaneously. There is no limit to the number of threads
that can be blocked in system calls on behalf of Go code; those do not count against
the GOMAXPROCS limit. This package&#39;s GOMAXPROCS function queries and changes
the limit.
</p>
<p>
The GOTRACEBACK variable controls the amount of output generated when a Go
program fails due to an unrecovered panic or an unexpected runtime condition.
By default, a failure prints a stack trace for every extant goroutine, eliding functions
internal to the run-time system, and then exits with exit code 2.
If GOTRACEBACK=0, the per-goroutine stack traces are omitted entirely.
If GOTRACEBACK=1, the default behavior is used.
If GOTRACEBACK=2, the per-goroutine stack traces include run-time functions.
If GOTRACEBACK=crash, the per-goroutine stack traces include run-time functions,
and if possible the program crashes in an operating-specific manner instead of
exiting. For example, on Unix systems, the program raises SIGABRT to trigger a
core dump.
</p>
<p>
The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete
the set of Go environment variables. They influence the building of Go programs
(see <a href="http://golang.org/cmd/go">http://golang.org/cmd/go</a> and <a href="http://golang.org/pkg/go/build">http://golang.org/pkg/go/build</a>).
GOARCH, GOOS, and GOROOT are recorded at compile time and made available by
constants or functions in this package, but they do not influence the execution
of the run-time system.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#BlockProfile">func BlockProfile(p []BlockProfileRecord) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#Breakpoint">func Breakpoint()</a></dd>
			
				
				<dd><a href="#CPUProfile">func CPUProfile() []byte</a></dd>
			
				
				<dd><a href="#Caller">func Caller(skip int) (pc uintptr, file string, line int, ok bool)</a></dd>
			
				
				<dd><a href="#Callers">func Callers(skip int, pc []uintptr) int</a></dd>
			
				
				<dd><a href="#GC">func GC()</a></dd>
			
				
				<dd><a href="#GOMAXPROCS">func GOMAXPROCS(n int) int</a></dd>
			
				
				<dd><a href="#GOROOT">func GOROOT() string</a></dd>
			
				
				<dd><a href="#Goexit">func Goexit()</a></dd>
			
				
				<dd><a href="#GoroutineProfile">func GoroutineProfile(p []StackRecord) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#Gosched">func Gosched()</a></dd>
			
				
				<dd><a href="#LockOSThread">func LockOSThread()</a></dd>
			
				
				<dd><a href="#MemProfile">func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#NumCPU">func NumCPU() int</a></dd>
			
				
				<dd><a href="#NumCgoCall">func NumCgoCall() int64</a></dd>
			
				
				<dd><a href="#NumGoroutine">func NumGoroutine() int</a></dd>
			
				
				<dd><a href="#ReadMemStats">func ReadMemStats(m *MemStats)</a></dd>
			
				
				<dd><a href="#SetBlockProfileRate">func SetBlockProfileRate(rate int)</a></dd>
			
				
				<dd><a href="#SetCPUProfileRate">func SetCPUProfileRate(hz int)</a></dd>
			
				
				<dd><a href="#SetFinalizer">func SetFinalizer(obj interface{}, finalizer interface{})</a></dd>
			
				
				<dd><a href="#Stack">func Stack(buf []byte, all bool) int</a></dd>
			
				
				<dd><a href="#ThreadCreateProfile">func ThreadCreateProfile(p []StackRecord) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#UnlockOSThread">func UnlockOSThread()</a></dd>
			
				
				<dd><a href="#Version">func Version() string</a></dd>
			
			
				
				<dd><a href="#BlockProfileRecord">type BlockProfileRecord</a></dd>
				
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
			
				
				<dd><a href="#Func">type Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncForPC">func FuncForPC(pc uintptr) *Func</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Entry">func (f *Func) Entry() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.FileLine">func (f *Func) FileLine(pc uintptr) (file string, line int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Name">func (f *Func) Name() string</a></dd>
				
			
				
				<dd><a href="#MemProfileRecord">type MemProfileRecord</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MemProfileRecord.InUseBytes">func (r *MemProfileRecord) InUseBytes() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MemProfileRecord.InUseObjects">func (r *MemProfileRecord) InUseObjects() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MemProfileRecord.Stack">func (r *MemProfileRecord) Stack() []uintptr</a></dd>
				
			
				
				<dd><a href="#MemStats">type MemStats</a></dd>
				
				
			
				
				<dd><a href="#StackRecord">type StackRecord</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StackRecord.Stack">func (r *StackRecord) Stack() []uintptr</a></dd>
				
			
				
				<dd><a href="#TypeAssertionError">type TypeAssertionError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssertionError.Error">func (e *TypeAssertionError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssertionError.RuntimeError">func (*TypeAssertionError) RuntimeError()</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/runtime/alg.go">alg.go</a>
			
				<a href="/src/runtime/arch_amd64.go">arch_amd64.go</a>
			
				<a href="/src/runtime/atomic.go">atomic.go</a>
			
				<a href="/src/runtime/cgocall.go">cgocall.go</a>
			
				<a href="/src/runtime/cgocallback.go">cgocallback.go</a>
			
				<a href="/src/runtime/chan.go">chan.go</a>
			
				<a href="/src/runtime/compiler.go">compiler.go</a>
			
				<a href="/src/runtime/complex.go">complex.go</a>
			
				<a href="/src/runtime/cpuprof.go">cpuprof.go</a>
			
				<a href="/src/runtime/debug.go">debug.go</a>
			
				<a href="/src/runtime/env_posix.go">env_posix.go</a>
			
				<a href="/src/runtime/error.go">error.go</a>
			
				<a href="/src/runtime/extern.go">extern.go</a>
			
				<a href="/src/runtime/hashmap.go">hashmap.go</a>
			
				<a href="/src/runtime/hashmap_fast.go">hashmap_fast.go</a>
			
				<a href="/src/runtime/iface.go">iface.go</a>
			
				<a href="/src/runtime/lock_futex.go">lock_futex.go</a>
			
				<a href="/src/runtime/malloc.go">malloc.go</a>
			
				<a href="/src/runtime/mem.go">mem.go</a>
			
				<a href="/src/runtime/mgc0.go">mgc0.go</a>
			
				<a href="/src/runtime/mprof.go">mprof.go</a>
			
				<a href="/src/runtime/netpoll.go">netpoll.go</a>
			
				<a href="/src/runtime/netpoll_epoll.go">netpoll_epoll.go</a>
			
				<a href="/src/runtime/os_linux.go">os_linux.go</a>
			
				<a href="/src/runtime/panic.go">panic.go</a>
			
				<a href="/src/runtime/print1.go">print1.go</a>
			
				<a href="/src/runtime/proc.go">proc.go</a>
			
				<a href="/src/runtime/race0.go">race0.go</a>
			
				<a href="/src/runtime/rdebug.go">rdebug.go</a>
			
				<a href="/src/runtime/rune.go">rune.go</a>
			
				<a href="/src/runtime/runtime.go">runtime.go</a>
			
				<a href="/src/runtime/select.go">select.go</a>
			
				<a href="/src/runtime/sema.go">sema.go</a>
			
				<a href="/src/runtime/signal_unix.go">signal_unix.go</a>
			
				<a href="/src/runtime/sigpanic_unix.go">sigpanic_unix.go</a>
			
				<a href="/src/runtime/sigqueue.go">sigqueue.go</a>
			
				<a href="/src/runtime/slice.go">slice.go</a>
			
				<a href="/src/runtime/softfloat64.go">softfloat64.go</a>
			
				<a href="/src/runtime/sqrt.go">sqrt.go</a>
			
				<a href="/src/runtime/stack.go">stack.go</a>
			
				<a href="/src/runtime/string.go">string.go</a>
			
				<a href="/src/runtime/stubs.go">stubs.go</a>
			
				<a href="/src/runtime/symtab.go">symtab.go</a>
			
				<a href="/src/runtime/time.go">time.go</a>
			
				<a href="/src/runtime/traceback.go">traceback.go</a>
			
				<a href="/src/runtime/typekind.go">typekind.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="Compiler">Compiler</span> = &#34;gc&#34;</pre>
				<p>
Compiler is the name of the compiler toolchain that built the
running binary.  Known toolchains are:
</p>
<pre>gc      The 5g/6g/8g compiler suite at code.google.com/p/go.
gccgo   The gccgo front end, part of the GCC compiler suite.
</pre>

			
				<pre>const <span id="GOARCH">GOARCH</span> <a href="/pkg/builtin/#string">string</a> = theGoarch</pre>
				<p>
GOARCH is the running program&#39;s architecture target:
386, amd64, or arm.
</p>

			
				<pre>const <span id="GOOS">GOOS</span> <a href="/pkg/builtin/#string">string</a> = theGoos</pre>
				<p>
GOOS is the running program&#39;s operating system target:
one of darwin, freebsd, linux, and so on.
</p>

			
				<pre>const (
        <span id="_">_</span> selectDir = <a href="/pkg/builtin/#iota">iota</a>
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var <span id="MemProfileRate">MemProfileRate</span> <a href="/pkg/builtin/#int">int</a> = 512 * 1024</pre>
				<p>
MemProfileRate controls the fraction of memory allocations
that are recorded and reported in the memory profile.
The profiler aims to sample an average of
one allocation per MemProfileRate bytes allocated.
</p>
<p>
To include every allocated block in the profile, set MemProfileRate to 1.
To turn off profiling entirely, set MemProfileRate to 0.
</p>
<p>
The tools that process the memory profiles assume that the
profile rate is constant across the lifetime of the program
and equal to the current value.  Programs that change the
memory profiling rate should do so just once, as early as
possible in the execution of the program (for example,
at the beginning of main).
</p>

			
		
		
			
			
			<h2 id="BlockProfile">func <a href="/src/runtime/mprof.go?s=13019:13077#L465">BlockProfile</a></h2>
			<pre>func BlockProfile(p []<a href="#BlockProfileRecord">BlockProfileRecord</a>) (n <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
BlockProfile returns n, the number of records in the current blocking profile.
If len(p) &gt;= n, BlockProfile copies the profile into p and returns n, true.
If len(p) &lt; n, BlockProfile does not change p and returns n, false.
</p>
<p>
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.blockprofile flag instead
of calling BlockProfile directly.
</p>

			
			

		
			
			
			<h2 id="Breakpoint">func <a href="/src/runtime/debug.go?s=236:253#L1">Breakpoint</a></h2>
			<pre>func Breakpoint()</pre>
			<p>
Breakpoint executes a breakpoint trap.
</p>

			
			

		
			
			
			<h2 id="CPUProfile">func <a href="/src/runtime/cpuprof.go?s=12068:12092#L413">CPUProfile</a></h2>
			<pre>func CPUProfile() []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
CPUProfile returns the next chunk of binary CPU profiling stack trace data,
blocking until data is available.  If profiling is turned off and all the profile
data accumulated while it was on has been returned, CPUProfile returns nil.
The caller must save the returned data before calling CPUProfile again.
</p>
<p>
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.cpuprofile flag instead of calling
CPUProfile directly.
</p>

			
			

		
			
			
			<h2 id="Caller">func <a href="/src/runtime/extern.go?s=4742:4808#L80">Caller</a></h2>
			<pre>func Caller(skip <a href="/pkg/builtin/#int">int</a>) (pc <a href="/pkg/builtin/#uintptr">uintptr</a>, file <a href="/pkg/builtin/#string">string</a>, line <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Caller reports file and line number information about function invocations on
the calling goroutine&#39;s stack.  The argument skip is the number of stack frames
to ascend, with 0 identifying the caller of Caller.  (For historical reasons the
meaning of skip differs between Caller and Callers.) The return values report the
program counter, file name, and line number within the file of the corresponding
call.  The boolean ok is false if it was not possible to recover the information.
</p>

			
			

		
			
			
			<h2 id="Callers">func <a href="/src/runtime/extern.go?s=6433:6473#L124">Callers</a></h2>
			<pre>func Callers(skip <a href="/pkg/builtin/#int">int</a>, pc []<a href="/pkg/builtin/#uintptr">uintptr</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Callers fills the slice pc with the return program counters of function invocations
on the calling goroutine&#39;s stack.  The argument skip is the number of stack frames
to skip before recording in pc, with 0 identifying the frame for Callers itself and
1 identifying the caller of Callers.
It returns the number of entries written to pc.
</p>
<p>
Note that since each slice entry pc[i] is a return program counter,
looking up the file and line for pc[i] (for example, using (*Func).FileLine)
will return the file and line number of the instruction immediately
following the call.
To look up the file and line number of the call itself, use pc[i]-1.
As an exception to this rule, if pc[i-1] corresponds to the function
runtime.sigpanic, then pc[i] is the program counter of a faulting
instruction and should be used without any subtraction.
</p>

			
			

		
			
			
			<h2 id="GC">func <a href="/src/runtime/malloc.go?s=13639:13648#L477">GC</a></h2>
			<pre>func GC()</pre>
			<p>
GC runs a garbage collection.
</p>

			
			

		
			
			
			<h2 id="GOMAXPROCS">func <a href="/src/runtime/debug.go?s=995:1021#L16">GOMAXPROCS</a></h2>
			<pre>func GOMAXPROCS(n <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
GOMAXPROCS sets the maximum number of CPUs that can be executing
simultaneously and returns the previous setting.  If n &lt; 1, it does not
change the current setting.
The number of logical CPUs on the local machine can be queried with NumCPU.
This call will go away when the scheduler improves.
</p>

			
			

		
			
			
			<h2 id="GOROOT">func <a href="/src/runtime/extern.go?s=6849:6869#L137">GOROOT</a></h2>
			<pre>func GOROOT() <a href="/pkg/builtin/#string">string</a></pre>
			<p>
GOROOT returns the root of the Go tree.
It uses the GOROOT environment variable, if set,
or else the root used during the Go build.
</p>

			
			

		
			
			
			<h2 id="Goexit">func <a href="/src/runtime/panic.go?s=7082:7095#L257">Goexit</a></h2>
			<pre>func Goexit()</pre>
			<p>
Goexit terminates the goroutine that calls it.  No other goroutine is affected.
Goexit runs all deferred calls before terminating the goroutine.  Because Goexit
is not panic, however, any recover calls in those deferred functions will return nil.
</p>
<p>
Calling Goexit from the main goroutine terminates that goroutine
without func main returning. Since func main has not returned,
the program continues execution of other goroutines.
If all other goroutines exit, the program crashes.
</p>

			
			

		
			
			
			<h2 id="GoroutineProfile">func <a href="/src/runtime/mprof.go?s=14572:14627#L520">GoroutineProfile</a></h2>
			<pre>func GoroutineProfile(p []<a href="#StackRecord">StackRecord</a>) (n <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
GoroutineProfile returns n, the number of records in the active goroutine stack profile.
If len(p) &gt;= n, GoroutineProfile copies the profile into p and returns n, true.
If len(p) &lt; n, GoroutineProfile does not change p and returns n, false.
</p>
<p>
Most clients should use the runtime/pprof package instead
of calling GoroutineProfile directly.
</p>

			
			

		
			
			
			<h2 id="Gosched">func <a href="/src/runtime/proc.go?s=2446:2460#L102">Gosched</a></h2>
			<pre>func Gosched()</pre>
			<p>
Gosched yields the processor, allowing other goroutines to run.  It does not
suspend the current goroutine, so execution resumes automatically.
</p>

			
			

		
			
			
			<h2 id="LockOSThread">func <a href="/src/runtime/debug.go?s=471:490#L5">LockOSThread</a></h2>
			<pre>func LockOSThread()</pre>
			<p>
LockOSThread wires the calling goroutine to its current operating system thread.
Until the calling goroutine exits or calls UnlockOSThread, it will always
execute in that thread, and no other goroutine can.
</p>

			
			

		
			
			
			<h2 id="MemProfile">func <a href="/src/runtime/mprof.go?s=10901:10971#L386">MemProfile</a></h2>
			<pre>func MemProfile(p []<a href="#MemProfileRecord">MemProfileRecord</a>, inuseZero <a href="/pkg/builtin/#bool">bool</a>) (n <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
MemProfile returns n, the number of records in the current memory profile.
If len(p) &gt;= n, MemProfile copies the profile into p and returns n, true.
If len(p) &lt; n, MemProfile does not change p and returns n, false.
</p>
<p>
If inuseZero is true, the profile includes allocation records
where r.AllocBytes &gt; 0 but r.AllocBytes == r.FreeBytes.
These are sites where memory was allocated, but it has all
been released back to the runtime.
</p>
<p>
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.memprofile flag instead
of calling MemProfile directly.
</p>

			
			

		
			
			
			<h2 id="NumCPU">func <a href="/src/runtime/debug.go?s=1472:1489#L42">NumCPU</a></h2>
			<pre>func NumCPU() <a href="/pkg/builtin/#int">int</a></pre>
			<p>
NumCPU returns the number of logical CPUs on the local machine.
</p>

			
			

		
			
			
			<h2 id="NumCgoCall">func <a href="/src/runtime/debug.go?s=1588:1611#L47">NumCgoCall</a></h2>
			<pre>func NumCgoCall() <a href="/pkg/builtin/#int64">int64</a></pre>
			<p>
NumCgoCall returns the number of cgo calls made by the current process.
</p>

			
			

		
			
			
			<h2 id="NumGoroutine">func <a href="/src/runtime/debug.go?s=1822:1845#L56">NumGoroutine</a></h2>
			<pre>func NumGoroutine() <a href="/pkg/builtin/#int">int</a></pre>
			<p>
NumGoroutine returns the number of goroutines that currently exist.
</p>

			
			

		
			
			
			<h2 id="ReadMemStats">func <a href="/src/runtime/mem.go?s=2417:2447#L63">ReadMemStats</a></h2>
			<pre>func ReadMemStats(m *<a href="#MemStats">MemStats</a>)</pre>
			<p>
ReadMemStats populates m with memory allocator statistics.
</p>

			
			

		
			
			
			<h2 id="SetBlockProfileRate">func <a href="/src/runtime/mprof.go?s=7258:7292#L273">SetBlockProfileRate</a></h2>
			<pre>func SetBlockProfileRate(rate <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
SetBlockProfileRate controls the fraction of goroutine blocking events
that are reported in the blocking profile.  The profiler aims to sample
an average of one blocking event per rate nanoseconds spent blocked.
</p>
<p>
To include every blocking event in the profile, pass rate = 1.
To turn off profiling entirely, pass rate &lt;= 0.
</p>

			
			

		
			
			
			<h2 id="SetCPUProfileRate">func <a href="/src/runtime/cpuprof.go?s=4806:4836#L114">SetCPUProfileRate</a></h2>
			<pre>func SetCPUProfileRate(hz <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
SetCPUProfileRate sets the CPU profiling rate to hz samples per second.
If hz &lt;= 0, SetCPUProfileRate turns off profiling.
If the profiler is on, the rate cannot be changed without first turning it off.
</p>
<p>
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.cpuprofile flag instead of calling
SetCPUProfileRate directly.
</p>

			
			

		
			
			
			<h2 id="SetFinalizer">func <a href="/src/runtime/malloc.go?s=16145:16202#L533">SetFinalizer</a></h2>
			<pre>func SetFinalizer(obj interface{}, finalizer interface{})</pre>
			<p>
SetFinalizer sets the finalizer associated with x to f.
When the garbage collector finds an unreachable block
with an associated finalizer, it clears the association and runs
f(x) in a separate goroutine.  This makes x reachable again, but
now without an associated finalizer.  Assuming that SetFinalizer
is not called again, the next time the garbage collector sees
that x is unreachable, it will free x.
</p>
<p>
SetFinalizer(x, nil) clears any finalizer associated with x.
</p>
<p>
The argument x must be a pointer to an object allocated by
calling new or by taking the address of a composite literal.
The argument f must be a function that takes a single argument
to which x&#39;s type can be assigned, and can have arbitrary ignored return
values. If either of these is not true, SetFinalizer aborts the
program.
</p>
<p>
Finalizers are run in dependency order: if A points at B, both have
finalizers, and they are otherwise unreachable, only the finalizer
for A runs; once A is freed, the finalizer for B can run.
If a cyclic structure includes a block with a finalizer, that
cycle is not guaranteed to be garbage collected and the finalizer
is not guaranteed to run, because there is no ordering that
respects the dependencies.
</p>
<p>
The finalizer for x is scheduled to run at some arbitrary time after
x becomes unreachable.
There is no guarantee that finalizers will run before a program exits,
so typically they are useful only for releasing non-memory resources
associated with an object during a long-running program.
For example, an os.File object could use a finalizer to close the
associated operating system file descriptor when a program discards
an os.File without calling Close, but it would be a mistake
to depend on a finalizer to flush an in-memory I/O buffer such as a
bufio.Writer, because the buffer would not be flushed at program exit.
</p>
<p>
It is not guaranteed that a finalizer will run if the size of *x is
zero bytes.
</p>
<p>
It is not guaranteed that a finalizer will run for objects allocated
in initializers for package-level variables. Such objects may be
linker-allocated, not heap-allocated.
</p>
<p>
A single goroutine runs all finalizers for a program, sequentially.
If a finalizer must run for a long time, it should do so by starting
a new goroutine.
</p>

			
			

		
			
			
			<h2 id="Stack">func <a href="/src/runtime/mprof.go?s=15639:15675#L567">Stack</a></h2>
			<pre>func Stack(buf []<a href="/pkg/builtin/#byte">byte</a>, all <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Stack formats a stack trace of the calling goroutine into buf
and returns the number of bytes written to buf.
If all is true, Stack formats stack traces of all other goroutines
into buf after the trace for the current goroutine.
</p>

			
			

		
			
			
			<h2 id="ThreadCreateProfile">func <a href="/src/runtime/mprof.go?s=13823:13881#L494">ThreadCreateProfile</a></h2>
			<pre>func ThreadCreateProfile(p []<a href="#StackRecord">StackRecord</a>) (n <a href="/pkg/builtin/#int">int</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
ThreadCreateProfile returns n, the number of records in the thread creation profile.
If len(p) &gt;= n, ThreadCreateProfile copies the profile into p and returns n, true.
If len(p) &lt; n, ThreadCreateProfile does not change p and returns n, false.
</p>
<p>
Most clients should use the runtime/pprof package instead
of calling ThreadCreateProfile directly.
</p>

			
			

		
			
			
			<h2 id="UnlockOSThread">func <a href="/src/runtime/debug.go?s=664:685#L9">UnlockOSThread</a></h2>
			<pre>func UnlockOSThread()</pre>
			<p>
UnlockOSThread unwires the calling goroutine from its fixed operating system thread.
If the calling goroutine has not called LockOSThread, UnlockOSThread is a no-op.
</p>

			
			

		
			
			
			<h2 id="Version">func <a href="/src/runtime/extern.go?s=7115:7136#L148">Version</a></h2>
			<pre>func Version() <a href="/pkg/builtin/#string">string</a></pre>
			<p>
Version returns the Go tree&#39;s version string.
It is either the commit hash and date at the time of the build or,
when possible, a release tag like &#34;go1.3&#34;.
</p>

			
			

		
		
			
			
			<h2 id="BlockProfileRecord">type <a href="/src/runtime/mprof.go?s=12557:12632#L452">BlockProfileRecord</a></h2>
			<pre>type BlockProfileRecord struct {
        Count  <a href="/pkg/builtin/#int64">int64</a>
        Cycles <a href="/pkg/builtin/#int64">int64</a>
        <a href="#StackRecord">StackRecord</a>
}</pre>
			<p>
BlockProfileRecord describes blocking events originated
at a particular call sequence (stack trace).
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Error">type <a href="/src/runtime/error.go?s=246:480#L1">Error</a></h2>
			<pre>type Error interface {
        <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// RuntimeError is a no-op function but</span>
        <span class="comment">// serves to distinguish types that are runtime</span>
        <span class="comment">// errors from ordinary errors: a type is a</span>
        <span class="comment">// runtime error if it has a RuntimeError method.</span>
        RuntimeError()
}</pre>
			<p>
The Error interface identifies a run time error.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Func">type <a href="/src/runtime/symtab.go?s=521:602#L5">Func</a></h2>
			<pre>type Func struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Func represents a Go function in the running binary.
</p>


			

			

			
			
			

			
				
				<h3 id="FuncForPC">func <a href="/src/runtime/symtab.go?s=3423:3455#L94">FuncForPC</a></h3>
				<pre>func FuncForPC(pc <a href="/pkg/builtin/#uintptr">uintptr</a>) *<a href="#Func">Func</a></pre>
				<p>
FuncForPC returns a *Func describing the function that contains the
given program counter address, or else nil.
</p>

				
				
			

			
				
				<h3 id="Func.Entry">func (*Func) <a href="/src/runtime/symtab.go?s=3663:3693#L104">Entry</a></h3>
				<pre>func (f *<a href="#Func">Func</a>) Entry() <a href="/pkg/builtin/#uintptr">uintptr</a></pre>
				<p>
Entry returns the entry address of the function.
</p>

				
				
				
			
				
				<h3 id="Func.FileLine">func (*Func) <a href="/src/runtime/symtab.go?s=3913:3972#L112">FileLine</a></h3>
				<pre>func (f *<a href="#Func">Func</a>) FileLine(pc <a href="/pkg/builtin/#uintptr">uintptr</a>) (file <a href="/pkg/builtin/#string">string</a>, line <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
FileLine returns the file name and line number of the
source code corresponding to the program counter pc.
The result will not be accurate if pc is not a program
counter within f.
</p>

				
				
				
			
				
				<h3 id="Func.Name">func (*Func) <a href="/src/runtime/symtab.go?s=3549:3577#L99">Name</a></h3>
				<pre>func (f *<a href="#Func">Func</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Name returns the name of the function.
</p>

				
				
				
			
		
			
			
			<h2 id="MemProfileRecord">type <a href="/src/runtime/mprof.go?s=9455:9732#L349">MemProfileRecord</a></h2>
			<pre>type MemProfileRecord struct {
        AllocBytes, FreeBytes     <a href="/pkg/builtin/#int64">int64</a>       <span class="comment">// number of bytes allocated, freed</span>
        AllocObjects, FreeObjects <a href="/pkg/builtin/#int64">int64</a>       <span class="comment">// number of objects allocated, freed</span>
        Stack0                    [32]<a href="/pkg/builtin/#uintptr">uintptr</a> <span class="comment">// stack trace for this record; ends at first 0 entry</span>
}</pre>
			<p>
A MemProfileRecord describes the live objects allocated
by a particular call sequence (stack trace).
</p>


			

			

			
			
			

			

			
				
				<h3 id="MemProfileRecord.InUseBytes">func (*MemProfileRecord) <a href="/src/runtime/mprof.go?s=9809:9854#L356">InUseBytes</a></h3>
				<pre>func (r *<a href="#MemProfileRecord">MemProfileRecord</a>) InUseBytes() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>
InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).
</p>

				
				
				
			
				
				<h3 id="MemProfileRecord.InUseObjects">func (*MemProfileRecord) <a href="/src/runtime/mprof.go?s=9977:10024#L359">InUseObjects</a></h3>
				<pre>func (r *<a href="#MemProfileRecord">MemProfileRecord</a>) InUseObjects() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>
InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).
</p>

				
				
				
			
				
				<h3 id="MemProfileRecord.Stack">func (*MemProfileRecord) <a href="/src/runtime/mprof.go?s=10155:10199#L365">Stack</a></h3>
				<pre>func (r *<a href="#MemProfileRecord">MemProfileRecord</a>) Stack() []<a href="/pkg/builtin/#uintptr">uintptr</a></pre>
				<p>
Stack returns the stack trace associated with the record,
a prefix of r.Stack0.
</p>

				
				
				
			
		
			
			
			<h2 id="MemStats">type <a href="/src/runtime/mem.go?s=342:2103#L3">MemStats</a></h2>
			<pre>type MemStats struct {
        <span class="comment">// General statistics.</span>
        Alloc      <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes allocated and still in use</span>
        TotalAlloc <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes allocated (even if freed)</span>
        Sys        <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes obtained from system (sum of XxxSys below)</span>
        Lookups    <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// number of pointer lookups</span>
        Mallocs    <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// number of mallocs</span>
        Frees      <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// number of frees</span>

        <span class="comment">// Main allocation heap statistics.</span>
        HeapAlloc    <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes allocated and still in use</span>
        HeapSys      <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes obtained from system</span>
        HeapIdle     <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes in idle spans</span>
        HeapInuse    <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes in non-idle span</span>
        HeapReleased <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes released to the OS</span>
        HeapObjects  <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// total number of allocated objects</span>

        <span class="comment">// Low-level fixed-size structure allocator statistics.</span>
        <span class="comment">//	Inuse is bytes used now.</span>
        <span class="comment">//	Sys is bytes obtained from system.</span>
        StackInuse  <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// bytes used by stack allocator</span>
        StackSys    <a href="/pkg/builtin/#uint64">uint64</a>
        MSpanInuse  <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// mspan structures</span>
        MSpanSys    <a href="/pkg/builtin/#uint64">uint64</a>
        MCacheInuse <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// mcache structures</span>
        MCacheSys   <a href="/pkg/builtin/#uint64">uint64</a>
        BuckHashSys <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// profiling bucket hash table</span>
        GCSys       <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// GC metadata</span>
        OtherSys    <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// other system allocations</span>

        <span class="comment">// Garbage collector statistics.</span>
        NextGC       <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// next collection will happen when HeapAlloc ≥ this amount</span>
        LastGC       <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// end time of last collection (nanoseconds since 1970)</span>
        PauseTotalNs <a href="/pkg/builtin/#uint64">uint64</a>
        PauseNs      [256]<a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// circular buffer of recent GC pause durations, most recent at [(NumGC+255)%256]</span>
        PauseEnd     [256]<a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// circular buffer of recent GC pause end times</span>
        NumGC        <a href="/pkg/builtin/#uint32">uint32</a>
        EnableGC     <a href="/pkg/builtin/#bool">bool</a>
        DebugGC      <a href="/pkg/builtin/#bool">bool</a>

        <span class="comment">// Per-size allocation statistics.</span>
        <span class="comment">// 61 is NumSizeClasses in the C code.</span>
        BySize [61]struct {
                Size    <a href="/pkg/builtin/#uint32">uint32</a>
                Mallocs <a href="/pkg/builtin/#uint64">uint64</a>
                Frees   <a href="/pkg/builtin/#uint64">uint64</a>
        }
}</pre>
			<p>
A MemStats records statistics about the memory allocator.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="StackRecord">type <a href="/src/runtime/mprof.go?s=8285:8386#L316">StackRecord</a></h2>
			<pre>type StackRecord struct {
        Stack0 [32]<a href="/pkg/builtin/#uintptr">uintptr</a> <span class="comment">// stack trace for this record; ends at first 0 entry</span>
}</pre>
			<p>
A StackRecord describes a single execution stack.
</p>


			

			

			
			
			

			

			
				
				<h3 id="StackRecord.Stack">func (*StackRecord) <a href="/src/runtime/mprof.go?s=8474:8513#L322">Stack</a></h3>
				<pre>func (r *<a href="#StackRecord">StackRecord</a>) Stack() []<a href="/pkg/builtin/#uintptr">uintptr</a></pre>
				<p>
Stack returns the stack trace associated with the record,
a prefix of r.Stack0.
</p>

				
				
				
			
		
			
			
			<h2 id="TypeAssertionError">type <a href="/src/runtime/error.go?s=540:727#L11">TypeAssertionError</a></h2>
			<pre>type TypeAssertionError struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A TypeAssertionError explains a failed type assertion.
</p>


			

			

			
			
			

			

			
				
				<h3 id="TypeAssertionError.Error">func (*TypeAssertionError) <a href="/src/runtime/error.go?s=775:818#L20">Error</a></h3>
				<pre>func (e *<a href="#TypeAssertionError">TypeAssertionError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssertionError.RuntimeError">func (*TypeAssertionError) <a href="/src/runtime/error.go?s=729:770#L18">RuntimeError</a></h3>
				<pre>func (*<a href="#TypeAssertionError">TypeAssertionError</a>) RuntimeError()</pre>
				
				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="cgo/">cgo</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package cgo contains runtime support for code generated by the cgo tool.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="debug/">debug</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package debug contains facilities for programs to debug themselves while they are running.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="pprof/">pprof</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="race/">race</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package race implements data race detection logic.</td>
			</tr>
		
	
	</table>

	



<div id="footer">
Build version go1.4.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="/lib/godoc/jquery.treeview.js"></script>
<script type="text/javascript" src="/lib/godoc/jquery.treeview.edit.js"></script>


<script type="text/javascript" src="/lib/godoc/playground.js"></script>

<script type="text/javascript" src="/lib/godoc/godocs.js"></script>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>

