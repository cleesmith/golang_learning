<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>net - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
<script type="text/javascript">window.initFuncs = [];</script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
</script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">

<form method="GET" action="/search">
<div id="menu">
<a href="/doc/">Documents</a>
<a href="/pkg/">Packages</a>
<a href="/project/">The Project</a>
<a href="/help/">Help</a>
<a href="/blog/">Blog</a>

<a id="playgroundButton" href="http://play.golang.org/" title="Show Go Playground">Play</a>

<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
</div>
<div id="heading"><a href="/">The Go Programming Language</a></div>
</form>

</div></div>


<div id="playground" class="play">
	<div class="input"><textarea class="code">package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}</textarea></div>
	<div class="output"></div>
	<div class="buttons">
		<a class="run" title="Run this code [shift-enter]">Run</a>
		<a class="fmt" title="Format this code">Format</a>
		<a class="share" title="Share this code">Share</a>
	</div>
</div>


<div id="page" class="wide">
<div class="container">


  <h1>Package net</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "net"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package net provides a portable interface for network I/O, including
TCP/IP, UDP, domain name resolution, and Unix domain sockets.
</p>
<p>
Although the package provides access to low-level networking
primitives, most clients will need only the basic interface provided
by the Dial, Listen, and Accept functions and the associated
Conn and Listener interfaces. The crypto/tls package uses
the same interfaces and similar Dial and Listen functions.
</p>
<p>
The Dial function connects to a server:
</p>
<pre>conn, err := net.Dial(&#34;tcp&#34;, &#34;google.com:80&#34;)
if err != nil {
	// handle error
}
fmt.Fprintf(conn, &#34;GET / HTTP/1.0\r\n\r\n&#34;)
status, err := bufio.NewReader(conn).ReadString(&#39;\n&#39;)
// ...
</pre>
<p>
The Listen function creates servers:
</p>
<pre>ln, err := net.Listen(&#34;tcp&#34;, &#34;:8080&#34;)
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
	}
	go handleConnection(conn)
}
</pre>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#InterfaceAddrs">func InterfaceAddrs() ([]Addr, error)</a></dd>
			
				
				<dd><a href="#Interfaces">func Interfaces() ([]Interface, error)</a></dd>
			
				
				<dd><a href="#JoinHostPort">func JoinHostPort(host, port string) string</a></dd>
			
				
				<dd><a href="#LookupAddr">func LookupAddr(addr string) (name []string, err error)</a></dd>
			
				
				<dd><a href="#LookupCNAME">func LookupCNAME(name string) (cname string, err error)</a></dd>
			
				
				<dd><a href="#LookupHost">func LookupHost(host string) (addrs []string, err error)</a></dd>
			
				
				<dd><a href="#LookupIP">func LookupIP(host string) (addrs []IP, err error)</a></dd>
			
				
				<dd><a href="#LookupMX">func LookupMX(name string) (mx []*MX, err error)</a></dd>
			
				
				<dd><a href="#LookupNS">func LookupNS(name string) (ns []*NS, err error)</a></dd>
			
				
				<dd><a href="#LookupPort">func LookupPort(network, service string) (port int, err error)</a></dd>
			
				
				<dd><a href="#LookupSRV">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></dd>
			
				
				<dd><a href="#LookupTXT">func LookupTXT(name string) (txt []string, err error)</a></dd>
			
				
				<dd><a href="#SplitHostPort">func SplitHostPort(hostport string) (host, port string, err error)</a></dd>
			
			
				
				<dd><a href="#Addr">type Addr</a></dd>
				
				
			
				
				<dd><a href="#AddrError">type AddrError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Error">func (e *AddrError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Temporary">func (e *AddrError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Timeout">func (e *AddrError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dial">func Dial(network, address string) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialTimeout">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileConn">func FileConn(f *os.File) (c Conn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pipe">func Pipe() (Conn, Conn)</a></dd>
				
				
			
				
				<dd><a href="#DNSConfigError">type DNSConfigError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Error">func (e *DNSConfigError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Temporary">func (e *DNSConfigError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Timeout">func (e *DNSConfigError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#DNSError">type DNSError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Error">func (e *DNSError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Temporary">func (e *DNSError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Timeout">func (e *DNSError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Dialer">type Dialer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Dialer.Dial">func (d *Dialer) Dial(network, address string) (Conn, error)</a></dd>
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
			
				
				<dd><a href="#Flags">type Flags</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Flags.String">func (f Flags) String() string</a></dd>
				
			
				
				<dd><a href="#HardwareAddr">type HardwareAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseMAC">func ParseMAC(s string) (hw HardwareAddr, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HardwareAddr.String">func (a HardwareAddr) String() string</a></dd>
				
			
				
				<dd><a href="#IP">type IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPv4">func IPv4(a, b, c, d byte) IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseCIDR">func ParseCIDR(s string) (IP, *IPNet, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseIP">func ParseIP(s string) IP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.DefaultMask">func (ip IP) DefaultMask() IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.Equal">func (ip IP) Equal(x IP) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsGlobalUnicast">func (ip IP) IsGlobalUnicast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsInterfaceLocalMulticast">func (ip IP) IsInterfaceLocalMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLinkLocalMulticast">func (ip IP) IsLinkLocalMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLinkLocalUnicast">func (ip IP) IsLinkLocalUnicast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLoopback">func (ip IP) IsLoopback() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsMulticast">func (ip IP) IsMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsUnspecified">func (ip IP) IsUnspecified() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.MarshalText">func (ip IP) MarshalText() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.Mask">func (ip IP) Mask(mask IPMask) IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.String">func (ip IP) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.To16">func (ip IP) To16() IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.To4">func (ip IP) To4() IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.UnmarshalText">func (ip *IP) UnmarshalText(text []byte) error</a></dd>
				
			
				
				<dd><a href="#IPAddr">type IPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveIPAddr">func ResolveIPAddr(net, addr string) (*IPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPAddr.Network">func (a *IPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPAddr.String">func (a *IPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#IPConn">type IPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialIP">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenIP">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Close">func (c *IPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.File">func (c *IPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.LocalAddr">func (c *IPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Read">func (c *IPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadFrom">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadFromIP">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadMsgIP">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.RemoteAddr">func (c *IPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetDeadline">func (c *IPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetReadBuffer">func (c *IPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetReadDeadline">func (c *IPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetWriteBuffer">func (c *IPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetWriteDeadline">func (c *IPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Write">func (c *IPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteMsgIP">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteTo">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteToIP">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a></dd>
				
			
				
				<dd><a href="#IPMask">type IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CIDRMask">func CIDRMask(ones, bits int) IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPv4Mask">func IPv4Mask(a, b, c, d byte) IPMask</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPMask.Size">func (m IPMask) Size() (ones, bits int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPMask.String">func (m IPMask) String() string</a></dd>
				
			
				
				<dd><a href="#IPNet">type IPNet</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.Contains">func (n *IPNet) Contains(ip IP) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.Network">func (n *IPNet) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.String">func (n *IPNet) String() string</a></dd>
				
			
				
				<dd><a href="#Interface">type Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceByIndex">func InterfaceByIndex(index int) (*Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceByName">func InterfaceByName(name string) (*Interface, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Addrs">func (ifi *Interface) Addrs() ([]Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.MulticastAddrs">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a></dd>
				
			
				
				<dd><a href="#InvalidAddrError">type InvalidAddrError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Error">func (e InvalidAddrError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Temporary">func (e InvalidAddrError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Timeout">func (e InvalidAddrError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Listener">type Listener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileListener">func FileListener(f *os.File) (l Listener, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Listen">func Listen(net, laddr string) (Listener, error)</a></dd>
				
				
			
				
				<dd><a href="#MX">type MX</a></dd>
				
				
			
				
				<dd><a href="#NS">type NS</a></dd>
				
				
			
				
				<dd><a href="#OpError">type OpError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Error">func (e *OpError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Temporary">func (e *OpError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Timeout">func (e *OpError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#PacketConn">type PacketConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FilePacketConn">func FilePacketConn(f *os.File) (c PacketConn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenPacket">func ListenPacket(net, laddr string) (PacketConn, error)</a></dd>
				
				
			
				
				<dd><a href="#ParseError">type ParseError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseError.Error">func (e *ParseError) Error() string</a></dd>
				
			
				
				<dd><a href="#SRV">type SRV</a></dd>
				
				
			
				
				<dd><a href="#TCPAddr">type TCPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveTCPAddr">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.Network">func (a *TCPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.String">func (a *TCPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#TCPConn">type TCPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialTCP">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Close">func (c *TCPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.CloseRead">func (c *TCPConn) CloseRead() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.CloseWrite">func (c *TCPConn) CloseWrite() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.File">func (c *TCPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.LocalAddr">func (c *TCPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Read">func (c *TCPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.ReadFrom">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.RemoteAddr">func (c *TCPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetDeadline">func (c *TCPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetKeepAlive">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetKeepAlivePeriod">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetLinger">func (c *TCPConn) SetLinger(sec int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetNoDelay">func (c *TCPConn) SetNoDelay(noDelay bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetReadBuffer">func (c *TCPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetReadDeadline">func (c *TCPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetWriteBuffer">func (c *TCPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetWriteDeadline">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Write">func (c *TCPConn) Write(b []byte) (int, error)</a></dd>
				
			
				
				<dd><a href="#TCPListener">type TCPListener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenTCP">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Accept">func (l *TCPListener) Accept() (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.AcceptTCP">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Addr">func (l *TCPListener) Addr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Close">func (l *TCPListener) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.File">func (l *TCPListener) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.SetDeadline">func (l *TCPListener) SetDeadline(t time.Time) error</a></dd>
				
			
				
				<dd><a href="#UDPAddr">type UDPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveUDPAddr">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.Network">func (a *UDPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.String">func (a *UDPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#UDPConn">type UDPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialUDP">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenMulticastUDP">func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUDP">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Close">func (c *UDPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.File">func (c *UDPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.LocalAddr">func (c *UDPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Read">func (c *UDPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFrom">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFromUDP">func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadMsgUDP">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.RemoteAddr">func (c *UDPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetDeadline">func (c *UDPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetReadBuffer">func (c *UDPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetReadDeadline">func (c *UDPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetWriteBuffer">func (c *UDPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetWriteDeadline">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Write">func (c *UDPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteMsgUDP">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteTo">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteToUDP">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a></dd>
				
			
				
				<dd><a href="#UnixAddr">type UnixAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveUnixAddr">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixAddr.Network">func (a *UnixAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixAddr.String">func (a *UnixAddr) String() string</a></dd>
				
			
				
				<dd><a href="#UnixConn">type UnixConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialUnix">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUnixgram">func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Close">func (c *UnixConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.CloseRead">func (c *UnixConn) CloseRead() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.CloseWrite">func (c *UnixConn) CloseWrite() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.File">func (c *UnixConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.LocalAddr">func (c *UnixConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Read">func (c *UnixConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadFrom">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadFromUnix">func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadMsgUnix">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.RemoteAddr">func (c *UnixConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetDeadline">func (c *UnixConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetReadBuffer">func (c *UnixConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetReadDeadline">func (c *UnixConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetWriteBuffer">func (c *UnixConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetWriteDeadline">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Write">func (c *UnixConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteMsgUnix">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteTo">func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteToUnix">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#UnixListener">type UnixListener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUnix">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Accept">func (l *UnixListener) Accept() (c Conn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.AcceptUnix">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Addr">func (l *UnixListener) Addr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Close">func (l *UnixListener) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.File">func (l *UnixListener) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.SetDeadline">func (l *UnixListener) SetDeadline(t time.Time) (err error)</a></dd>
				
			
				
				<dd><a href="#UnknownNetworkError">type UnknownNetworkError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Error">func (e UnknownNetworkError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Temporary">func (e UnknownNetworkError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Timeout">func (e UnknownNetworkError) Timeout() bool</a></dd>
				
			
			
				
				<dd><a href="#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h4>Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Listener">Listener</a></dd>
			
			</dl>
		</div>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/net/cgo_linux.go">cgo_linux.go</a>
			
				<a href="/src/net/cgo_unix.go">cgo_unix.go</a>
			
				<a href="/src/net/dial.go">dial.go</a>
			
				<a href="/src/net/dnsclient.go">dnsclient.go</a>
			
				<a href="/src/net/dnsclient_unix.go">dnsclient_unix.go</a>
			
				<a href="/src/net/dnsconfig_unix.go">dnsconfig_unix.go</a>
			
				<a href="/src/net/dnsmsg.go">dnsmsg.go</a>
			
				<a href="/src/net/fd_mutex.go">fd_mutex.go</a>
			
				<a href="/src/net/fd_poll_runtime.go">fd_poll_runtime.go</a>
			
				<a href="/src/net/fd_unix.go">fd_unix.go</a>
			
				<a href="/src/net/file_unix.go">file_unix.go</a>
			
				<a href="/src/net/hosts.go">hosts.go</a>
			
				<a href="/src/net/interface.go">interface.go</a>
			
				<a href="/src/net/interface_linux.go">interface_linux.go</a>
			
				<a href="/src/net/ip.go">ip.go</a>
			
				<a href="/src/net/iprawsock.go">iprawsock.go</a>
			
				<a href="/src/net/iprawsock_posix.go">iprawsock_posix.go</a>
			
				<a href="/src/net/ipsock.go">ipsock.go</a>
			
				<a href="/src/net/ipsock_posix.go">ipsock_posix.go</a>
			
				<a href="/src/net/lookup.go">lookup.go</a>
			
				<a href="/src/net/lookup_unix.go">lookup_unix.go</a>
			
				<a href="/src/net/mac.go">mac.go</a>
			
				<a href="/src/net/net.go">net.go</a>
			
				<a href="/src/net/parse.go">parse.go</a>
			
				<a href="/src/net/pipe.go">pipe.go</a>
			
				<a href="/src/net/port.go">port.go</a>
			
				<a href="/src/net/port_unix.go">port_unix.go</a>
			
				<a href="/src/net/sendfile_linux.go">sendfile_linux.go</a>
			
				<a href="/src/net/singleflight.go">singleflight.go</a>
			
				<a href="/src/net/sock_cloexec.go">sock_cloexec.go</a>
			
				<a href="/src/net/sock_linux.go">sock_linux.go</a>
			
				<a href="/src/net/sock_posix.go">sock_posix.go</a>
			
				<a href="/src/net/sockopt_linux.go">sockopt_linux.go</a>
			
				<a href="/src/net/sockopt_posix.go">sockopt_posix.go</a>
			
				<a href="/src/net/sockoptip_linux.go">sockoptip_linux.go</a>
			
				<a href="/src/net/sockoptip_posix.go">sockoptip_posix.go</a>
			
				<a href="/src/net/tcpsock.go">tcpsock.go</a>
			
				<a href="/src/net/tcpsock_posix.go">tcpsock_posix.go</a>
			
				<a href="/src/net/tcpsockopt_posix.go">tcpsockopt_posix.go</a>
			
				<a href="/src/net/tcpsockopt_unix.go">tcpsockopt_unix.go</a>
			
				<a href="/src/net/udpsock.go">udpsock.go</a>
			
				<a href="/src/net/udpsock_posix.go">udpsock_posix.go</a>
			
				<a href="/src/net/unixsock.go">unixsock.go</a>
			
				<a href="/src/net/unixsock_posix.go">unixsock_posix.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
        <span id="IPv4len">IPv4len</span> = 4
        <span id="IPv6len">IPv6len</span> = 16
)</pre>
				<p>
IP address lengths (bytes).
</p>

			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
        <span id="IPv4bcast">IPv4bcast</span>     = <a href="#IPv4">IPv4</a>(255, 255, 255, 255) <span class="comment">// broadcast</span>
        <span id="IPv4allsys">IPv4allsys</span>    = <a href="#IPv4">IPv4</a>(224, 0, 0, 1)       <span class="comment">// all systems</span>
        <span id="IPv4allrouter">IPv4allrouter</span> = <a href="#IPv4">IPv4</a>(224, 0, 0, 2)       <span class="comment">// all routers</span>
        <span id="IPv4zero">IPv4zero</span>      = <a href="#IPv4">IPv4</a>(0, 0, 0, 0)         <span class="comment">// all zeros</span>
)</pre>
				<p>
Well-known IPv4 addresses
</p>

			
				<pre>var (
        <span id="IPv6zero">IPv6zero</span>                   = <a href="#IP">IP</a>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        <span id="IPv6unspecified">IPv6unspecified</span>            = <a href="#IP">IP</a>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        <span id="IPv6loopback">IPv6loopback</span>               = <a href="#IP">IP</a>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
        <span id="IPv6interfacelocalallnodes">IPv6interfacelocalallnodes</span> = <a href="#IP">IP</a>{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
        <span id="IPv6linklocalallnodes">IPv6linklocalallnodes</span>      = <a href="#IP">IP</a>{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
        <span id="IPv6linklocalallrouters">IPv6linklocalallrouters</span>    = <a href="#IP">IP</a>{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)</pre>
				<p>
Well-known IPv6 addresses
</p>

			
				<pre>var (
        <span id="ErrWriteToConnected">ErrWriteToConnected</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;use of WriteTo with pre-connected connection&#34;)
)</pre>
				<p>
Various errors contained in OpError.
</p>

			
		
		
			
			
			<h2 id="InterfaceAddrs">func <a href="/src/net/interface.go?s=2447:2484#L76">InterfaceAddrs</a></h2>
			<pre>func InterfaceAddrs() ([]<a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
InterfaceAddrs returns a list of the system&#39;s network interface
addresses.
</p>

			
			

		
			
			
			<h2 id="Interfaces">func <a href="/src/net/interface.go?s=2296:2334#L70">Interfaces</a></h2>
			<pre>func Interfaces() ([]<a href="#Interface">Interface</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
Interfaces returns a list of the system&#39;s network interfaces.
</p>

			
			

		
			
			
			<h2 id="JoinHostPort">func <a href="/src/net/ipsock.go?s=5811:5854#L213">JoinHostPort</a></h2>
			<pre>func JoinHostPort(host, port <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>
JoinHostPort combines host and port into a network address of the
form &#34;host:port&#34; or, if host contains a colon or a percent sign,
&#34;[host]:port&#34;.
</p>

			
			

		
			
			
			<h2 id="LookupAddr">func <a href="/src/net/lookup.go?s=4358:4413#L130">LookupAddr</a></h2>
			<pre>func LookupAddr(addr <a href="/pkg/builtin/#string">string</a>) (name []<a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
</p>

			
			

		
			
			
			<h2 id="LookupCNAME">func <a href="/src/net/lookup.go?s=3072:3127#L96">LookupCNAME</a></h2>
			<pre>func LookupCNAME(name <a href="/pkg/builtin/#string">string</a>) (cname <a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupCNAME returns the canonical DNS host for the given name.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.
</p>

			
			

		
			
			
			<h2 id="LookupHost">func <a href="/src/net/lookup.go?s=694:750#L14">LookupHost</a></h2>
			<pre>func LookupHost(host <a href="/pkg/builtin/#string">string</a>) (addrs []<a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupHost looks up the given host using the local resolver.
It returns an array of that host&#39;s addresses.
</p>

			
			

		
			
			
			<h2 id="LookupIP">func <a href="/src/net/lookup.go?s=896:946#L20">LookupIP</a></h2>
			<pre>func LookupIP(host <a href="/pkg/builtin/#string">string</a>) (addrs []<a href="#IP">IP</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupIP looks up host using the local resolver.
It returns an array of that host&#39;s IPv4 and IPv6 addresses.
</p>

			
			

		
			
			
			<h2 id="LookupMX">func <a href="/src/net/lookup.go?s=3870:3918#L114">LookupMX</a></h2>
			<pre>func LookupMX(name <a href="/pkg/builtin/#string">string</a>) (mx []*<a href="#MX">MX</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupMX returns the DNS MX records for the given domain name sorted by preference.
</p>

			
			

		
			
			
			<h2 id="LookupNS">func <a href="/src/net/lookup.go?s=4013:4061#L119">LookupNS</a></h2>
			<pre>func LookupNS(name <a href="/pkg/builtin/#string">string</a>) (ns []*<a href="#NS">NS</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupNS returns the DNS NS records for the given domain name.
</p>

			
			

		
			
			
			<h2 id="LookupPort">func <a href="/src/net/lookup.go?s=2730:2792#L88">LookupPort</a></h2>
			<pre>func LookupPort(network, service <a href="/pkg/builtin/#string">string</a>) (port <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupPort looks up the port for the given network and service.
</p>

			
			

		
			
			
			<h2 id="LookupSRV">func <a href="/src/net/lookup.go?s=3654:3737#L109">LookupSRV</a></h2>
			<pre>func LookupSRV(service, proto, name <a href="/pkg/builtin/#string">string</a>) (cname <a href="/pkg/builtin/#string">string</a>, addrs []*<a href="#SRV">SRV</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name.  The proto is &#34;tcp&#34; or &#34;udp&#34;.
The returned records are sorted by priority and randomized
by weight within a priority.
</p>
<p>
LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name.  To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
</p>

			
			

		
			
			
			<h2 id="LookupTXT">func <a href="/src/net/lookup.go?s=4158:4211#L124">LookupTXT</a></h2>
			<pre>func LookupTXT(name <a href="/pkg/builtin/#string">string</a>) (txt []<a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
LookupTXT returns the DNS TXT records for the given domain name.
</p>

			
			

		
			
			
			<h2 id="SplitHostPort">func <a href="/src/net/ipsock.go?s=3941:4007#L133">SplitHostPort</a></h2>
			<pre>func SplitHostPort(hostport <a href="/pkg/builtin/#string">string</a>) (host, port <a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
SplitHostPort splits a network address of the form &#34;host:port&#34;,
&#34;[host]:port&#34; or &#34;[ipv6-host%zone]:port&#34; into host or
ipv6-host%zone and port.  A literal address or host name for IPv6
must be enclosed in square brackets, as in &#34;[::1]:80&#34;,
&#34;[ipv6-host]:http&#34; or &#34;[ipv6-host%zone]:80&#34;.
</p>

			
			

		
		
			
			
			<h2 id="Addr">type <a href="/src/net/net.go?s=1228:1336#L43">Addr</a></h2>
			<pre>type Addr interface {
        Network() <a href="/pkg/builtin/#string">string</a> <span class="comment">// name of the network</span>
        String() <a href="/pkg/builtin/#string">string</a>  <span class="comment">// string form of address</span>
}</pre>
			<p>
Addr represents a network end point address.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="AddrError">type <a href="/src/net/net.go?s=9696:9747#L338">AddrError</a></h2>
			<pre>type AddrError struct {
        Err  <a href="/pkg/builtin/#string">string</a>
        Addr <a href="/pkg/builtin/#string">string</a>
}</pre>
			

			

			

			
			
			

			

			
				
				<h3 id="AddrError.Error">func (*AddrError) <a href="/src/net/net.go?s=9749:9783#L343">Error</a></h3>
				<pre>func (e *<a href="#AddrError">AddrError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="AddrError.Temporary">func (*AddrError) <a href="/src/net/net.go?s=9888:9924#L354">Temporary</a></h3>
				<pre>func (e *<a href="#AddrError">AddrError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="AddrError.Timeout">func (*AddrError) <a href="/src/net/net.go?s=9944:9978#L358">Timeout</a></h3>
				<pre>func (e *<a href="#AddrError">AddrError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Conn">type <a href="/src/net/net.go?s=1466:3231#L51">Conn</a></h2>
			<pre>type Conn interface {
        <span class="comment">// Read reads data from the connection.</span>
        <span class="comment">// Read can be made to time out and return a Error with Timeout() == true</span>
        <span class="comment">// after a fixed time limit; see SetDeadline and SetReadDeadline.</span>
        Read(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)

        <span class="comment">// Write writes data to the connection.</span>
        <span class="comment">// Write can be made to time out and return a Error with Timeout() == true</span>
        <span class="comment">// after a fixed time limit; see SetDeadline and SetWriteDeadline.</span>
        Write(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)

        <span class="comment">// Close closes the connection.</span>
        <span class="comment">// Any blocked Read or Write operations will be unblocked and return errors.</span>
        Close() <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// LocalAddr returns the local network address.</span>
        LocalAddr() <a href="#Addr">Addr</a>

        <span class="comment">// RemoteAddr returns the remote network address.</span>
        RemoteAddr() <a href="#Addr">Addr</a>

        <span class="comment">// SetDeadline sets the read and write deadlines associated</span>
        <span class="comment">// with the connection. It is equivalent to calling both</span>
        <span class="comment">// SetReadDeadline and SetWriteDeadline.</span>
        <span class="comment">//</span>
        <span class="comment">// A deadline is an absolute time after which I/O operations</span>
        <span class="comment">// fail with a timeout (see type Error) instead of</span>
        <span class="comment">// blocking. The deadline applies to all future I/O, not just</span>
        <span class="comment">// the immediately following call to Read or Write.</span>
        <span class="comment">//</span>
        <span class="comment">// An idle timeout can be implemented by repeatedly extending</span>
        <span class="comment">// the deadline after successful Read or Write calls.</span>
        <span class="comment">//</span>
        <span class="comment">// A zero value for t means I/O operations will not time out.</span>
        SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// SetReadDeadline sets the deadline for future Read calls.</span>
        <span class="comment">// A zero value for t means Read will not time out.</span>
        SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// SetWriteDeadline sets the deadline for future Write calls.</span>
        <span class="comment">// Even if write times out, it may return n &gt; 0, indicating that</span>
        <span class="comment">// some of the data was successfully written.</span>
        <span class="comment">// A zero value for t means Write will not time out.</span>
        SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
Conn is a generic stream-oriented network connection.
</p>
<p>
Multiple goroutines may invoke methods on a Conn simultaneously.
</p>


			

			

			
			
			

			
				
				<h3 id="Dial">func <a href="/src/net/dial.go?s=4151:4199#L131">Dial</a></h3>
				<pre>func Dial(network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Dial connects to the address on the named network.
</p>
<p>
Known networks are &#34;tcp&#34;, &#34;tcp4&#34; (IPv4-only), &#34;tcp6&#34; (IPv6-only),
&#34;udp&#34;, &#34;udp4&#34; (IPv4-only), &#34;udp6&#34; (IPv6-only), &#34;ip&#34;, &#34;ip4&#34;
(IPv4-only), &#34;ip6&#34; (IPv6-only), &#34;unix&#34;, &#34;unixgram&#34; and
&#34;unixpacket&#34;.
</p>
<p>
For TCP and UDP networks, addresses have the form host:port.
If host is a literal IPv6 address it must be enclosed
in square brackets as in &#34;[::1]:80&#34; or &#34;[ipv6-host%zone]:80&#34;.
The functions JoinHostPort and SplitHostPort manipulate addresses
in this form.
</p>
<p>
Examples:
</p>
<pre>Dial(&#34;tcp&#34;, &#34;12.34.56.78:80&#34;)
Dial(&#34;tcp&#34;, &#34;google.com:http&#34;)
Dial(&#34;tcp&#34;, &#34;[2001:db8::1]:http&#34;)
Dial(&#34;tcp&#34;, &#34;[fe80::1%lo0]:80&#34;)
</pre>
<p>
For IP networks, the network must be &#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34; followed
by a colon and a protocol number or name and the addr must be a
literal IP address.
</p>
<p>
Examples:
</p>
<pre>Dial(&#34;ip4:1&#34;, &#34;127.0.0.1&#34;)
Dial(&#34;ip6:ospf&#34;, &#34;::1&#34;)
</pre>
<p>
For Unix networks, the address must be a file system path.
</p>

				
				
			
				
				<h3 id="DialTimeout">func <a href="/src/net/dial.go?s=4357:4435#L138">DialTimeout</a></h3>
				<pre>func DialTimeout(network, address <a href="/pkg/builtin/#string">string</a>, timeout <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
DialTimeout acts like Dial but takes a timeout.
The timeout includes name resolution, if required.
</p>

				
				
			
				
				<h3 id="FileConn">func <a href="/src/net/file_unix.go?s=2004:2049#L72">FileConn</a></h3>
				<pre>func FileConn(f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>) (c <a href="#Conn">Conn</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
FileConn returns a copy of the network connection corresponding to
the open file f.  It is the caller&#39;s responsibility to close f when
finished.  Closing c does not affect f, and closing f does not
affect c.
</p>

				
				
			
				
				<h3 id="Pipe">func <a href="/src/net/pipe.go?s=462:486#L8">Pipe</a></h3>
				<pre>func Pipe() (<a href="#Conn">Conn</a>, <a href="#Conn">Conn</a>)</pre>
				<p>
Pipe creates a synchronous, in-memory, full duplex
network connection; both ends implement the Conn interface.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal
buffering.
</p>

				
				
			

			
		
			
			
			<h2 id="DNSConfigError">type <a href="/src/net/net.go?s=10540:10581#L375">DNSConfigError</a></h2>
			<pre>type DNSConfigError struct {
        Err <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
DNSConfigError represents an error reading the machine&#39;s DNS configuration.
</p>


			

			

			
			
			

			

			
				
				<h3 id="DNSConfigError.Error">func (*DNSConfigError) <a href="/src/net/net.go?s=10583:10622#L379">Error</a></h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="DNSConfigError.Temporary">func (*DNSConfigError) <a href="/src/net/net.go?s=10740:10781#L384">Temporary</a></h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="DNSConfigError.Timeout">func (*DNSConfigError) <a href="/src/net/net.go?s=10681:10720#L383">Timeout</a></h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="DNSError">type <a href="/src/net/dnsclient.go?s=249:405#L3">DNSError</a></h2>
			<pre>type DNSError struct {
        Err       <a href="/pkg/builtin/#string">string</a> <span class="comment">// description of the error</span>
        Name      <a href="/pkg/builtin/#string">string</a> <span class="comment">// name looked for</span>
        Server    <a href="/pkg/builtin/#string">string</a> <span class="comment">// server used</span>
        IsTimeout <a href="/pkg/builtin/#bool">bool</a>
}</pre>
			<p>
DNSError represents a DNS lookup error.
</p>


			

			

			
			
			

			

			
				
				<h3 id="DNSError.Error">func (*DNSError) <a href="/src/net/dnsclient.go?s=407:440#L10">Error</a></h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="DNSError.Temporary">func (*DNSError) <a href="/src/net/dnsclient.go?s=643:678#L23">Temporary</a></h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="DNSError.Timeout">func (*DNSError) <a href="/src/net/dnsclient.go?s=584:617#L22">Timeout</a></h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Dialer">type <a href="/src/net/dial.go?s=448:1779#L7">Dialer</a></h2>
			<pre>type Dialer struct {
        <span class="comment">// Timeout is the maximum amount of time a dial will wait for</span>
        <span class="comment">// a connect to complete. If Deadline is also set, it may fail</span>
        <span class="comment">// earlier.</span>
        <span class="comment">//</span>
        <span class="comment">// The default is no timeout.</span>
        <span class="comment">//</span>
        <span class="comment">// With or without a timeout, the operating system may impose</span>
        <span class="comment">// its own earlier timeout. For instance, TCP timeouts are</span>
        <span class="comment">// often around 3 minutes.</span>
        Timeout <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>

        <span class="comment">// Deadline is the absolute point in time after which dials</span>
        <span class="comment">// will fail. If Timeout is set, it may fail earlier.</span>
        <span class="comment">// Zero means no deadline, or dependent on the operating system</span>
        <span class="comment">// as with the Timeout option.</span>
        Deadline <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>

        <span class="comment">// LocalAddr is the local address to use when dialing an</span>
        <span class="comment">// address. The address must be of a compatible type for the</span>
        <span class="comment">// network being dialed.</span>
        <span class="comment">// If nil, a local address is automatically chosen.</span>
        LocalAddr <a href="#Addr">Addr</a>

        <span class="comment">// DualStack allows a single dial to attempt to establish</span>
        <span class="comment">// multiple IPv4 and IPv6 connections and to return the first</span>
        <span class="comment">// established connection when the network is &#34;tcp&#34; and the</span>
        <span class="comment">// destination is a host name that has multiple address family</span>
        <span class="comment">// DNS records.</span>
        DualStack <a href="/pkg/builtin/#bool">bool</a>

        <span class="comment">// KeepAlive specifies the keep-alive period for an active</span>
        <span class="comment">// network connection.</span>
        <span class="comment">// If zero, keep-alives are not enabled. Network protocols</span>
        <span class="comment">// that do not support keep-alives ignore this field.</span>
        KeepAlive <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>
}</pre>
			<p>
A Dialer contains options for connecting to an address.
</p>
<p>
The zero value for each field is equivalent to dialing
without that option. Dialing with the zero value of Dialer
is therefore equivalent to just calling the Dial function.
</p>


			

			

			
			
			

			

			
				
				<h3 id="Dialer.Dial">func (*Dialer) <a href="/src/net/dial.go?s=4639:4699#L147">Dial</a></h3>
				<pre>func (d *<a href="#Dialer">Dialer</a>) Dial(network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Dial connects to the address on the named network.
</p>
<p>
See func Dial for a description of the network and address
parameters.
</p>

				
				
				
			
		
			
			
			<h2 id="Error">type <a href="/src/net/net.go?s=5619:5740#L198">Error</a></h2>
			<pre>type Error interface {
        <a href="/pkg/builtin/#error">error</a>
        Timeout() <a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// Is the error a timeout?</span>
        Temporary() <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Is the error temporary?</span>
}</pre>
			<p>
An Error represents a network error.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Flags">type <a href="/src/net/interface.go?s=1086:1101#L18">Flags</a></h2>
			<pre>type Flags <a href="/pkg/builtin/#uint">uint</a></pre>
			

			
				<pre>const (
        <span id="FlagUp">FlagUp</span>           <a href="#Flags">Flags</a> = 1 &lt;&lt; <a href="/pkg/builtin/#iota">iota</a> <span class="comment">// interface is up</span>
        <span id="FlagBroadcast">FlagBroadcast</span>                      <span class="comment">// interface supports broadcast access capability</span>
        <span id="FlagLoopback">FlagLoopback</span>                       <span class="comment">// interface is a loopback interface</span>
        <span id="FlagPointToPoint">FlagPointToPoint</span>                   <span class="comment">// interface belongs to a point-to-point link</span>
        <span id="FlagMulticast">FlagMulticast</span>                      <span class="comment">// interface supports multicast access capability</span>
)</pre>
				
			

			

			
			
			

			

			
				
				<h3 id="Flags.String">func (Flags) <a href="/src/net/interface.go?s=1590:1620#L36">String</a></h3>
				<pre>func (f <a href="#Flags">Flags</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="HardwareAddr">type <a href="/src/net/mac.go?s=316:340#L4">HardwareAddr</a></h2>
			<pre>type HardwareAddr []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
A HardwareAddr represents a physical hardware address.
</p>


			

			

			
			
			

			
				
				<h3 id="ParseMAC">func <a href="/src/net/mac.go?s=866:918#L29">ParseMAC</a></h3>
				<pre>func ParseMAC(s <a href="/pkg/builtin/#string">string</a>) (hw <a href="#HardwareAddr">HardwareAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, or EUI-64 using one of the
following formats:
</p>
<pre>01:23:45:67:89:ab
01:23:45:67:89:ab:cd:ef
01-23-45-67-89-ab
01-23-45-67-89-ab-cd-ef
0123.4567.89ab
0123.4567.89ab.cdef
</pre>

				
				
			

			
				
				<h3 id="HardwareAddr.String">func (HardwareAddr) <a href="/src/net/mac.go?s=342:379#L6">String</a></h3>
				<pre>func (a <a href="#HardwareAddr">HardwareAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="IP">type <a href="/src/net/ip.go?s=936:950#L22">IP</a></h2>
			<pre>type IP []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
An IP is a single IP address, a slice of bytes.
Functions in this package accept either 4-byte (IPv4)
or 16-byte (IPv6) slices as input.
</p>
<p>
Note that in this documentation, referring to an
IP address as an IPv4 address or an IPv6 address
is a semantic property of the address, not just the
length of the byte slice: a 16-byte slice can still
be an IPv4 address.
</p>


			

			

			
			
			

			
				
				<h3 id="IPv4">func <a href="/src/net/ip.go?s=1206:1235#L35">IPv4</a></h3>
				<pre>func IPv4(a, b, c, d <a href="/pkg/builtin/#byte">byte</a>) <a href="#IP">IP</a></pre>
				<p>
IPv4 returns the IP address (in 16-byte form) of the
IPv4 address a.b.c.d.
</p>

				
				
			
				
				<h3 id="ParseCIDR">func <a href="/src/net/ip.go?s=15055:15099#L661">ParseCIDR</a></h3>
				<pre>func ParseCIDR(s <a href="/pkg/builtin/#string">string</a>) (<a href="#IP">IP</a>, *<a href="#IPNet">IPNet</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseCIDR parses s as a CIDR notation IP address and mask,
like &#34;192.168.100.1/24&#34; or &#34;2001:DB8::/48&#34;, as defined in
RFC 4632 and RFC 4291.
</p>
<p>
It returns the IP address and the network implied by the IP
and mask.  For example, ParseCIDR(&#34;192.168.100.1/16&#34;) returns
the IP address 192.168.100.1 and the network 192.168.0.0/16.
</p>

				
				
			
				
				<h3 id="ParseIP">func <a href="/src/net/ip.go?s=14522:14547#L641">ParseIP</a></h3>
				<pre>func ParseIP(s <a href="/pkg/builtin/#string">string</a>) <a href="#IP">IP</a></pre>
				<p>
ParseIP parses s as an IP address, returning the result.
The string s can be in dotted decimal (&#34;74.125.19.99&#34;)
or IPv6 (&#34;2001:4860:0:2001::68&#34;) form.
If s is not a valid textual representation of an IP address,
ParseIP returns nil.
</p>

				
				
			

			
				
				<h3 id="IP.DefaultMask">func (IP) <a href="/src/net/ip.go?s=5509:5542#L205">DefaultMask</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) DefaultMask() <a href="#IPMask">IPMask</a></pre>
				<p>
DefaultMask returns the default IP mask for the IP address ip.
Only IPv4 addresses have default masks; DefaultMask returns
nil if ip is not a valid IPv4 address.
</p>

				
				
				
			
				
				<h3 id="IP.Equal">func (IP) <a href="/src/net/ip.go?s=8550:8579#L348">Equal</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) Equal(x <a href="#IP">IP</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Equal returns true if ip and x are the same IP address.
An IPv4 address and that same address in IPv6 form are
considered to be equal.
</p>

				
				
				
			
				
				<h3 id="IP.IsGlobalUnicast">func (IP) <a href="/src/net/ip.go?s=4306:4341#L151">IsGlobalUnicast</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsGlobalUnicast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsGlobalUnicast returns true if ip is a global unicast
address.
</p>

				
				
				
			
				
				<h3 id="IP.IsInterfaceLocalMulticast">func (IP) <a href="/src/net/ip.go?s=3600:3645#L127">IsInterfaceLocalMulticast</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsInterfaceLocalMulticast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsInterfaceLinkLocalMulticast returns true if ip is
an interface-local multicast address.
</p>

				
				
				
			
				
				<h3 id="IP.IsLinkLocalMulticast">func (IP) <a href="/src/net/ip.go?s=3798:3838#L133">IsLinkLocalMulticast</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsLinkLocalMulticast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsLinkLocalMulticast returns true if ip is a link-local
multicast address.
</p>

				
				
				
			
				
				<h3 id="IP.IsLinkLocalUnicast">func (IP) <a href="/src/net/ip.go?s=4063:4101#L142">IsLinkLocalUnicast</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsLinkLocalUnicast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsLinkLocalUnicast returns true if ip is a link-local
unicast address.
</p>

				
				
				
			
				
				<h3 id="IP.IsLoopback">func (IP) <a href="/src/net/ip.go?s=3178:3208#L110">IsLoopback</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsLoopback() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsLoopback returns true if ip is a loopback address.
</p>

				
				
				
			
				
				<h3 id="IP.IsMulticast">func (IP) <a href="/src/net/ip.go?s=3371:3402#L118">IsMulticast</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsMulticast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsMulticast returns true if ip is a multicast address.
</p>

				
				
				
			
				
				<h3 id="IP.IsUnspecified">func (IP) <a href="/src/net/ip.go?s=2998:3031#L102">IsUnspecified</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) IsUnspecified() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
IsUnspecified returns true if ip is an unspecified address.
</p>

				
				
				
			
				
				<h3 id="IP.MarshalText">func (IP) <a href="/src/net/ip.go?s=7838:7880#L319">MarshalText</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) MarshalText() ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
MarshalText implements the encoding.TextMarshaler interface.
The encoding is the same as returned by String.
</p>

				
				
				
			
				
				<h3 id="IP.Mask">func (IP) <a href="/src/net/ip.go?s=5897:5930#L229">Mask</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) Mask(mask <a href="#IPMask">IPMask</a>) <a href="#IP">IP</a></pre>
				<p>
Mask returns the result of masking the IP address ip with mask.
</p>

				
				
				
			
				
				<h3 id="IP.String">func (IP) <a href="/src/net/ip.go?s=6496:6524#L251">String</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the string form of the IP address ip.
If the address is an IPv4 address, the string representation
is dotted decimal (&#34;74.125.19.99&#34;).  Otherwise the representation
is IPv6 (&#34;2001:4860:0:2001::68&#34;).
</p>

				
				
				
			
				
				<h3 id="IP.To16">func (IP) <a href="/src/net/ip.go?s=5023:5045#L185">To16</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) To16() <a href="#IP">IP</a></pre>
				<p>
To16 converts the IP address ip to a 16-byte representation.
If ip is not an IP address (it is the wrong length), To16 returns nil.
</p>

				
				
				
			
				
				<h3 id="IP.To4">func (IP) <a href="/src/net/ip.go?s=4696:4717#L170">To4</a></h3>
				<pre>func (ip <a href="#IP">IP</a>) To4() <a href="#IP">IP</a></pre>
				<p>
To4 converts the IPv4 address ip to a 4-byte representation.
If ip is not an IPv4 address, To4 returns nil.
</p>

				
				
				
			
				
				<h3 id="IP.UnmarshalText">func (*IP) <a href="/src/net/ip.go?s=8192:8238#L331">UnmarshalText</a></h3>
				<pre>func (ip *<a href="#IP">IP</a>) UnmarshalText(text []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnmarshalText implements the encoding.TextUnmarshaler interface.
The IP address is expected in a form accepted by ParseIP.
</p>

				
				
				
			
		
			
			
			<h2 id="IPAddr">type <a href="/src/net/iprawsock.go?s=227:302#L1">IPAddr</a></h2>
			<pre>type IPAddr struct {
        IP   <a href="#IP">IP</a>
        Zone <a href="/pkg/builtin/#string">string</a> <span class="comment">// IPv6 scoped addressing zone</span>
}</pre>
			<p>
IPAddr represents the address of an IP end point.
</p>


			

			

			
			
			

			
				
				<h3 id="ResolveIPAddr">func <a href="/src/net/iprawsock.go?s=816:869#L26">ResolveIPAddr</a></h3>
				<pre>func ResolveIPAddr(net, addr <a href="/pkg/builtin/#string">string</a>) (*<a href="#IPAddr">IPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ResolveIPAddr parses addr as an IP address of the form &#34;host&#34; or
&#34;ipv6-host%zone&#34; and resolves the domain name on the network net,
which must be &#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34;.
</p>

				
				
			

			
				
				<h3 id="IPAddr.Network">func (*IPAddr) <a href="/src/net/iprawsock.go?s=357:390#L4">Network</a></h3>
				<pre>func (a *<a href="#IPAddr">IPAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Network returns the address&#39;s network name, &#34;ip&#34;.
</p>

				
				
				
			
				
				<h3 id="IPAddr.String">func (*IPAddr) <a href="/src/net/iprawsock.go?s=408:440#L6">String</a></h3>
				<pre>func (a *<a href="#IPAddr">IPAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="IPConn">type <a href="/src/net/iprawsock_posix.go?s=1653:1681#L52">IPConn</a></h2>
			<pre>type IPConn struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
IPConn is the implementation of the Conn and PacketConn interfaces
for IP network connections.
</p>


			

			

			
			
			

			
				
				<h3 id="DialIP">func <a href="/src/net/iprawsock_posix.go?s=5511:5578#L174">DialIP</a></h3>
				<pre>func DialIP(netProto <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#IPAddr">IPAddr</a>) (*<a href="#IPConn">IPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
DialIP connects to the remote address raddr on the network protocol
netProto, which must be &#34;ip&#34;, &#34;ip4&#34;, or &#34;ip6&#34; followed by a colon
and a protocol number or name.
</p>

				
				
			
				
				<h3 id="ListenIP">func <a href="/src/net/iprawsock_posix.go?s=6550:6612#L202">ListenIP</a></h3>
				<pre>func ListenIP(netProto <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#IPAddr">IPAddr</a>) (*<a href="#IPConn">IPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenIP listens for incoming IP packets addressed to the local
address laddr.  The returned connection&#39;s ReadFrom and WriteTo
methods can be used to receive and send IP packets with per-packet
addressing.
</p>

				
				
			

			
				
				<h3 id="IPConn.Close">func (*IPConn) <a href="/src/net/net.go?s=3713:3741#L123">Close</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the connection.
</p>

				
				
				
			
				
				<h3 id="IPConn.File">func (*IPConn) <a href="/src/net/net.go?s=5510:5555#L195">File</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
File sets the underlying os.File to blocking mode and returns a copy.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
<p>
The returned os.File&#39;s file descriptor is different from the connection&#39;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.
</p>

				
				
				
			
				
				<h3 id="IPConn.LocalAddr">func (*IPConn) <a href="/src/net/net.go?s=3857:3888#L131">LocalAddr</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
				
			
				
				<h3 id="IPConn.Read">func (*IPConn) <a href="/src/net/net.go?s=3410:3452#L107">Read</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
				
			
				
				<h3 id="IPConn.ReadFrom">func (*IPConn) <a href="/src/net/iprawsock_posix.go?s=2722:2776#L88">ReadFrom</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom implements the PacketConn ReadFrom method.
</p>

				
				
				
			
				
				<h3 id="IPConn.ReadFromIP">func (*IPConn) <a href="/src/net/iprawsock_posix.go?s=2067:2126#L65">ReadFromIP</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) ReadFromIP(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, *<a href="#IPAddr">IPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFromIP reads an IP packet from c, copying the payload into b.
It returns the number of bytes copied into b and the return address
that was on the packet.
</p>
<p>
ReadFromIP can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetReadDeadline.
</p>

				
				
				
			
				
				<h3 id="IPConn.ReadMsgIP">func (*IPConn) <a href="/src/net/iprawsock_posix.go?s=3172:3259#L100">ReadMsgIP</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) ReadMsgIP(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr *<a href="#IPAddr">IPAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadMsgIP reads a packet from c, copying the payload into b and the
associated out-of-band data into oob.  It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the packet and the source address of the packet.
</p>

				
				
				
			
				
				<h3 id="IPConn.RemoteAddr">func (*IPConn) <a href="/src/net/net.go?s=3993:4025#L139">RemoteAddr</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>
RemoteAddr returns the remote network address.
</p>

				
				
				
			
				
				<h3 id="IPConn.SetDeadline">func (*IPConn) <a href="/src/net/net.go?s=4135:4180#L147">SetDeadline</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
				
			
				
				<h3 id="IPConn.SetReadBuffer">func (*IPConn) <a href="/src/net/net.go?s=4748:4793#L172">SetReadBuffer</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="IPConn.SetReadDeadline">func (*IPConn) <a href="/src/net/net.go?s=4318:4367#L155">SetReadDeadline</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
				
			
				
				<h3 id="IPConn.SetWriteBuffer">func (*IPConn) <a href="/src/net/net.go?s=4984:5030#L181">SetWriteBuffer</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="IPConn.SetWriteDeadline">func (*IPConn) <a href="/src/net/net.go?s=4511:4561#L163">SetWriteDeadline</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
				
			
				
				<h3 id="IPConn.Write">func (*IPConn) <a href="/src/net/net.go?s=3566:3609#L115">Write</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
				
			
				
				<h3 id="IPConn.WriteMsgIP">func (*IPConn) <a href="/src/net/iprawsock_posix.go?s=4832:4913#L154">WriteMsgIP</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) WriteMsgIP(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#IPAddr">IPAddr</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteMsgIP writes a packet to addr via c, copying the payload from
b and the associated out-of-band data from oob.  It returns the
number of payload and out-of-band bytes written.
</p>

				
				
				
			
				
				<h3 id="IPConn.WriteTo">func (*IPConn) <a href="/src/net/iprawsock_posix.go?s=4409:4467#L140">WriteTo</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo implements the PacketConn WriteTo method.
</p>

				
				
				
			
				
				<h3 id="IPConn.WriteToIP">func (*IPConn) <a href="/src/net/iprawsock_posix.go?s=3887:3950#L122">WriteToIP</a></h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) WriteToIP(b []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#IPAddr">IPAddr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteToIP writes an IP packet to addr via c, copying the payload
from b.
</p>
<p>
WriteToIP can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetWriteDeadline.  On packet-oriented connections, write timeouts
are rare.
</p>

				
				
				
			
		
			
			
			<h2 id="IPMask">type <a href="/src/net/ip.go?s=984:1002#L25">IPMask</a></h2>
			<pre>type IPMask []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>
An IP mask is an IP address.
</p>


			

			

			
			
			

			
				
				<h3 id="CIDRMask">func <a href="/src/net/ip.go?s=1791:1827#L61">CIDRMask</a></h3>
				<pre>func CIDRMask(ones, bits <a href="/pkg/builtin/#int">int</a>) <a href="#IPMask">IPMask</a></pre>
				<p>
CIDRMask returns an IPMask consisting of `ones&#39; 1 bits
followed by 0s up to a total length of `bits&#39; bits.
For a mask of this form, CIDRMask is the inverse of IPMask.Size.
</p>

				
				
			
				
				<h3 id="IPv4Mask">func <a href="/src/net/ip.go?s=1489:1526#L49">IPv4Mask</a></h3>
				<pre>func IPv4Mask(a, b, c, d <a href="/pkg/builtin/#byte">byte</a>) <a href="#IPMask">IPMask</a></pre>
				<p>
IPv4Mask returns the IP mask (in 4-byte form) of the
IPv4 mask a.b.c.d.
</p>

				
				
			

			
				
				<h3 id="IPMask.Size">func (IPMask) <a href="/src/net/ip.go?s=9660:9699#L405">Size</a></h3>
				<pre>func (m <a href="#IPMask">IPMask</a>) Size() (ones, bits <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Size returns the number of leading ones and total bits in the mask.
If the mask is not in the canonical form--ones followed by zeros--then
Size returns 0, 0.
</p>

				
				
				
			
				
				<h3 id="IPMask.String">func (IPMask) <a href="/src/net/ip.go?s=9857:9888#L414">String</a></h3>
				<pre>func (m <a href="#IPMask">IPMask</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the hexadecimal form of m, with no punctuation.
</p>

				
				
				
			
		
			
			
			<h2 id="IPNet">type <a href="/src/net/ip.go?s=1042:1123#L28">IPNet</a></h2>
			<pre>type IPNet struct {
        IP   <a href="#IP">IP</a>     <span class="comment">// network number</span>
        Mask <a href="#IPMask">IPMask</a> <span class="comment">// network mask</span>
}</pre>
			<p>
An IPNet represents an IP network.
</p>


			

			

			
			
			

			

			
				
				<h3 id="IPNet.Contains">func (*IPNet) <a href="/src/net/ip.go?s=10466:10502#L449">Contains</a></h3>
				<pre>func (n *<a href="#IPNet">IPNet</a>) Contains(ip <a href="#IP">IP</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Contains reports whether the network includes ip.
</p>

				
				
				
			
				
				<h3 id="IPNet.Network">func (*IPNet) <a href="/src/net/ip.go?s=10786:10818#L467">Network</a></h3>
				<pre>func (n *<a href="#IPNet">IPNet</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Network returns the address&#39;s network name, &#34;ip+net&#34;.
</p>

				
				
				
			
				
				<h3 id="IPNet.String">func (*IPNet) <a href="/src/net/ip.go?s=11195:11226#L475">String</a></h3>
				<pre>func (n *<a href="#IPNet">IPNet</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the CIDR notation of n like &#34;192.168.100.1/24&#34;
or &#34;2001:DB8::/48&#34; as defined in RFC 4632 and RFC 4291.
If the mask is not in the canonical form, it returns the
string which consists of an IP address, followed by a slash
character and a mask expressed as hexadecimal form with no
punctuation like &#34;192.168.100.1/c000ff00&#34;.
</p>

				
				
				
			
		
			
			
			<h2 id="Interface">type <a href="/src/net/interface.go?s=718:1084#L10">Interface</a></h2>
			<pre>type Interface struct {
        Index        <a href="/pkg/builtin/#int">int</a>          <span class="comment">// positive integer that starts at one, zero is never used</span>
        MTU          <a href="/pkg/builtin/#int">int</a>          <span class="comment">// maximum transmission unit</span>
        Name         <a href="/pkg/builtin/#string">string</a>       <span class="comment">// e.g., &#34;en0&#34;, &#34;lo0&#34;, &#34;eth0.100&#34;</span>
        HardwareAddr <a href="#HardwareAddr">HardwareAddr</a> <span class="comment">// IEEE MAC-48, EUI-48 and EUI-64 form</span>
        Flags        <a href="#Flags">Flags</a>        <span class="comment">// e.g., FlagUp, FlagLoopback, FlagMulticast</span>
}</pre>
			<p>
Interface represents a mapping between network interface name
and index.  It also represents network interface facility
information.
</p>


			

			

			
			
			

			
				
				<h3 id="InterfaceByIndex">func <a href="/src/net/interface.go?s=2584:2636#L81">InterfaceByIndex</a></h3>
				<pre>func InterfaceByIndex(index <a href="/pkg/builtin/#int">int</a>) (*<a href="#Interface">Interface</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterfaceByIndex returns the interface specified by index.
</p>

				
				
			
				
				<h3 id="InterfaceByName">func <a href="/src/net/interface.go?s=3058:3111#L102">InterfaceByName</a></h3>
				<pre>func InterfaceByName(name <a href="/pkg/builtin/#string">string</a>) (*<a href="#Interface">Interface</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
InterfaceByName returns the interface specified by name.
</p>

				
				
			

			
				
				<h3 id="Interface.Addrs">func (*Interface) <a href="/src/net/interface.go?s=1850:1895#L53">Addrs</a></h3>
				<pre>func (ifi *<a href="#Interface">Interface</a>) Addrs() ([]<a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Addrs returns interface addresses for a specific interface.
</p>

				
				
				
			
				
				<h3 id="Interface.MulticastAddrs">func (*Interface) <a href="/src/net/interface.go?s=2076:2130#L62">MulticastAddrs</a></h3>
				<pre>func (ifi *<a href="#Interface">Interface</a>) MulticastAddrs() ([]<a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastAddrs returns multicast, joined group addresses for
a specific interface.
</p>

				
				
				
			
		
			
			
			<h2 id="InvalidAddrError">type <a href="/src/net/net.go?s=10246:10274#L368">InvalidAddrError</a></h2>
			<pre>type InvalidAddrError <a href="/pkg/builtin/#string">string</a></pre>
			

			

			

			
			
			

			

			
				
				<h3 id="InvalidAddrError.Error">func (InvalidAddrError) <a href="/src/net/net.go?s=10276:10316#L370">Error</a></h3>
				<pre>func (e <a href="#InvalidAddrError">InvalidAddrError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="InvalidAddrError.Temporary">func (InvalidAddrError) <a href="/src/net/net.go?s=10400:10442#L372">Temporary</a></h3>
				<pre>func (e <a href="#InvalidAddrError">InvalidAddrError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="InvalidAddrError.Timeout">func (InvalidAddrError) <a href="/src/net/net.go?s=10340:10380#L371">Timeout</a></h3>
				<pre>func (e <a href="#InvalidAddrError">InvalidAddrError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Listener">type <a href="/src/net/net.go?s=7752:8060#L255">Listener</a></h2>
			<pre>type Listener interface {
        <span class="comment">// Accept waits for and returns the next connection to the listener.</span>
        Accept() (c <a href="#Conn">Conn</a>, err <a href="/pkg/builtin/#error">error</a>)

        <span class="comment">// Close closes the listener.</span>
        <span class="comment">// Any blocked Accept operations will be unblocked and return errors.</span>
        Close() <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// Addr returns the listener&#39;s network address.</span>
        Addr() <a href="#Addr">Addr</a>
}</pre>
			<p>
A Listener is a generic network listener for stream-oriented protocols.
</p>
<p>
Multiple goroutines may invoke methods on a Listener simultaneously.
</p>


			

			

			<div id="example_Listener" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code">package main

import (
	&#34;io&#34;
	&#34;log&#34;
	&#34;net&#34;
)

func main() {
	// Listen on TCP port 2000 on all interfaces.
	l, err := net.Listen(&#34;tcp&#34;, &#34;:2000&#34;)
	if err != nil {
		log.Fatal(err)
	}
	defer l.Close()
	for {
		// Wait for a connection.
		conn, err := l.Accept()
		if err != nil {
			log.Fatal(err)
		}
		// Handle the connection in a new goroutine.
		// The loop then returns to accepting, so that
		// multiple connections may be served concurrently.
		go func(c net.Conn) {
			// Echo all incoming data.
			io.Copy(c, c)
			// Shut down the connection.
			c.Close()
		}(conn)
	}
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					<a class="share" title="Share this code">Share</a>
				</div>
			</div>
		
	</div>
</div>

			
			

			
				
				<h3 id="FileListener">func <a href="/src/net/file_unix.go?s=2589:2642#L95">FileListener</a></h3>
				<pre>func FileListener(f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>) (l <a href="#Listener">Listener</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
FileListener returns a copy of the network listener corresponding
to the open file f.  It is the caller&#39;s responsibility to close l
when finished.  Closing l does not affect f, and closing f does not
affect l.
</p>

				
				
			
				
				<h3 id="Listen">func <a href="/src/net/dial.go?s=7809:7857#L248">Listen</a></h3>
				<pre>func Listen(net, laddr <a href="/pkg/builtin/#string">string</a>) (<a href="#Listener">Listener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Listen announces on the local network address laddr.
The network net must be a stream-oriented network: &#34;tcp&#34;, &#34;tcp4&#34;,
&#34;tcp6&#34;, &#34;unix&#34; or &#34;unixpacket&#34;.
See Dial for the syntax of laddr.
</p>

				
				
			

			
		
			
			
			<h2 id="MX">type <a href="/src/net/dnsclient.go?s=5491:5535#L213">MX</a></h2>
			<pre>type MX struct {
        Host <a href="/pkg/builtin/#string">string</a>
        Pref <a href="/pkg/builtin/#uint16">uint16</a>
}</pre>
			<p>
An MX represents a single DNS MX record.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="NS">type <a href="/src/net/dnsclient.go?s=6013:6044#L237">NS</a></h2>
			<pre>type NS struct {
        Host <a href="/pkg/builtin/#string">string</a>
}</pre>
			<p>
An NS represents a single DNS NS record.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="OpError">type <a href="/src/net/net.go?s=8611:8967#L281">OpError</a></h2>
			<pre>type OpError struct {
        <span class="comment">// Op is the operation which caused the error, such as</span>
        <span class="comment">// &#34;read&#34; or &#34;write&#34;.</span>
        Op <a href="/pkg/builtin/#string">string</a>

        <span class="comment">// Net is the network type on which this error occurred,</span>
        <span class="comment">// such as &#34;tcp&#34; or &#34;udp6&#34;.</span>
        Net <a href="/pkg/builtin/#string">string</a>

        <span class="comment">// Addr is the network address on which this error occurred.</span>
        Addr <a href="#Addr">Addr</a>

        <span class="comment">// Err is the error that occurred during the operation.</span>
        Err <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
OpError is the error type usually returned by functions in the net
package. It describes the operation, network type, and address of
an error.
</p>


			

			

			
			
			

			

			
				
				<h3 id="OpError.Error">func (*OpError) <a href="/src/net/net.go?s=8969:9001#L297">Error</a></h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="OpError.Temporary">func (*OpError) <a href="/src/net/net.go?s=9230:9264#L316">Temporary</a></h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="OpError.Timeout">func (*OpError) <a href="/src/net/net.go?s=9400:9432#L327">Timeout</a></h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PacketConn">type <a href="/src/net/net.go?s=5882:7556#L207">PacketConn</a></h2>
			<pre>type PacketConn interface {
        <span class="comment">// ReadFrom reads a packet from the connection,</span>
        <span class="comment">// copying the payload into b.  It returns the number of</span>
        <span class="comment">// bytes copied into b and the return address that</span>
        <span class="comment">// was on the packet.</span>
        <span class="comment">// ReadFrom can be made to time out and return</span>
        <span class="comment">// an error with Timeout() == true after a fixed time limit;</span>
        <span class="comment">// see SetDeadline and SetReadDeadline.</span>
        ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr <a href="#Addr">Addr</a>, err <a href="/pkg/builtin/#error">error</a>)

        <span class="comment">// WriteTo writes a packet with payload b to addr.</span>
        <span class="comment">// WriteTo can be made to time out and return</span>
        <span class="comment">// an error with Timeout() == true after a fixed time limit;</span>
        <span class="comment">// see SetDeadline and SetWriteDeadline.</span>
        <span class="comment">// On packet-oriented connections, write timeouts are rare.</span>
        WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)

        <span class="comment">// Close closes the connection.</span>
        <span class="comment">// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.</span>
        Close() <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// LocalAddr returns the local network address.</span>
        LocalAddr() <a href="#Addr">Addr</a>

        <span class="comment">// SetDeadline sets the read and write deadlines associated</span>
        <span class="comment">// with the connection.</span>
        SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// SetReadDeadline sets the deadline for future Read calls.</span>
        <span class="comment">// If the deadline is reached, Read will fail with a timeout</span>
        <span class="comment">// (see type Error) instead of blocking.</span>
        <span class="comment">// A zero value for t means Read will not time out.</span>
        SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

        <span class="comment">// SetWriteDeadline sets the deadline for future Write calls.</span>
        <span class="comment">// If the deadline is reached, Write will fail with a timeout</span>
        <span class="comment">// (see type Error) instead of blocking.</span>
        <span class="comment">// A zero value for t means Write will not time out.</span>
        <span class="comment">// Even if write times out, it may return n &gt; 0, indicating that</span>
        <span class="comment">// some of the data was successfully written.</span>
        SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>
}</pre>
			<p>
PacketConn is a generic packet-oriented network connection.
</p>
<p>
Multiple goroutines may invoke methods on a PacketConn simultaneously.
</p>


			

			

			
			
			

			
				
				<h3 id="FilePacketConn">func <a href="/src/net/file_unix.go?s=3130:3187#L114">FilePacketConn</a></h3>
				<pre>func FilePacketConn(f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>) (c <a href="#PacketConn">PacketConn</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
FilePacketConn returns a copy of the packet network connection
corresponding to the open file f.  It is the caller&#39;s
responsibility to close f when finished.  Closing c does not affect
f, and closing f does not affect c.
</p>

				
				
			
				
				<h3 id="ListenPacket">func <a href="/src/net/dial.go?s=8601:8657#L272">ListenPacket</a></h3>
				<pre>func ListenPacket(net, laddr <a href="/pkg/builtin/#string">string</a>) (<a href="#PacketConn">PacketConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenPacket announces on the local network address laddr.
The network net must be a packet-oriented network: &#34;udp&#34;, &#34;udp4&#34;,
&#34;udp6&#34;, &#34;ip&#34;, &#34;ip4&#34;, &#34;ip6&#34; or &#34;unixgram&#34;.
See Dial for the syntax of laddr.
</p>

				
				
			

			
		
			
			
			<h2 id="ParseError">type <a href="/src/net/ip.go?s=14135:14187#L627">ParseError</a></h2>
			<pre>type ParseError struct {
        Type <a href="/pkg/builtin/#string">string</a>
        Text <a href="/pkg/builtin/#string">string</a>
}</pre>
			<p>
A ParseError represents a malformed text string and the type of string that was expected.
</p>


			

			

			
			
			

			

			
				
				<h3 id="ParseError.Error">func (*ParseError) <a href="/src/net/ip.go?s=14189:14224#L632">Error</a></h3>
				<pre>func (e *<a href="#ParseError">ParseError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SRV">type <a href="/src/net/dnsclient.go?s=4206:4293#L156">SRV</a></h2>
			<pre>type SRV struct {
        Target   <a href="/pkg/builtin/#string">string</a>
        Port     <a href="/pkg/builtin/#uint16">uint16</a>
        Priority <a href="/pkg/builtin/#uint16">uint16</a>
        Weight   <a href="/pkg/builtin/#uint16">uint16</a>
}</pre>
			<p>
An SRV represents a single DNS SRV record.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="TCPAddr">type <a href="/src/net/tcpsock.go?s=228:314#L1">TCPAddr</a></h2>
			<pre>type TCPAddr struct {
        IP   <a href="#IP">IP</a>
        Port <a href="/pkg/builtin/#int">int</a>
        Zone <a href="/pkg/builtin/#string">string</a> <span class="comment">// IPv6 scoped addressing zone</span>
}</pre>
			<p>
TCPAddr represents the address of a TCP end point.
</p>


			

			

			
			
			

			
				
				<h3 id="ResolveTCPAddr">func <a href="/src/net/tcpsock.go?s=1076:1131#L31">ResolveTCPAddr</a></h3>
				<pre>func ResolveTCPAddr(net, addr <a href="/pkg/builtin/#string">string</a>) (*<a href="#TCPAddr">TCPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ResolveTCPAddr parses addr as a TCP address of the form &#34;host:port&#34;
or &#34;[ipv6-host%zone]:port&#34; and resolves a pair of domain name and
port name on the network net, which must be &#34;tcp&#34;, &#34;tcp4&#34; or
&#34;tcp6&#34;.  A literal address or host name for IPv6 must be enclosed
in square brackets, as in &#34;[::1]:80&#34;, &#34;[ipv6-host]:http&#34; or
&#34;[ipv6-host%zone]:80&#34;.
</p>

				
				
			

			
				
				<h3 id="TCPAddr.Network">func (*TCPAddr) <a href="/src/net/tcpsock.go?s=370:404#L5">Network</a></h3>
				<pre>func (a *<a href="#TCPAddr">TCPAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Network returns the address&#39;s network name, &#34;tcp&#34;.
</p>

				
				
				
			
				
				<h3 id="TCPAddr.String">func (*TCPAddr) <a href="/src/net/tcpsock.go?s=423:456#L7">String</a></h3>
				<pre>func (a *<a href="#TCPAddr">TCPAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="TCPConn">type <a href="/src/net/tcpsock_posix.go?s=1425:1454#L47">TCPConn</a></h2>
			<pre>type TCPConn struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
TCPConn is an implementation of the Conn interface for TCP network
connections.
</p>


			

			

			
			
			

			
				
				<h3 id="DialTCP">func <a href="/src/net/tcpsock_posix.go?s=3796:3861#L133">DialTCP</a></h3>
				<pre>func DialTCP(net <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#TCPAddr">TCPAddr</a>) (*<a href="#TCPConn">TCPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
DialTCP connects to the remote address raddr on the network net,
which must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.  If laddr is not nil, it is
used as the local address for the connection.
</p>

				
				
			

			
				
				<h3 id="TCPConn.Close">func (*TCPConn) <a href="/src/net/net.go?s=3713:3741#L123">Close</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the connection.
</p>

				
				
				
			
				
				<h3 id="TCPConn.CloseRead">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=1874:1909#L67">CloseRead</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) CloseRead() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CloseRead shuts down the reading side of the TCP connection.
Most callers should just use Close.
</p>

				
				
				
			
				
				<h3 id="TCPConn.CloseWrite">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=2085:2121#L76">CloseWrite</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) CloseWrite() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CloseWrite shuts down the writing side of the TCP connection.
Most callers should just use Close.
</p>

				
				
				
			
				
				<h3 id="TCPConn.File">func (*TCPConn) <a href="/src/net/net.go?s=5510:5555#L195">File</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
File sets the underlying os.File to blocking mode and returns a copy.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
<p>
The returned os.File&#39;s file descriptor is different from the connection&#39;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.
</p>

				
				
				
			
				
				<h3 id="TCPConn.LocalAddr">func (*TCPConn) <a href="/src/net/net.go?s=3857:3888#L131">LocalAddr</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
				
			
				
				<h3 id="TCPConn.Read">func (*TCPConn) <a href="/src/net/net.go?s=3410:3452#L107">Read</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
				
			
				
				<h3 id="TCPConn.ReadFrom">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=1610:1664#L58">ReadFrom</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) ReadFrom(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom implements the io.ReaderFrom ReadFrom method.
</p>

				
				
				
			
				
				<h3 id="TCPConn.RemoteAddr">func (*TCPConn) <a href="/src/net/net.go?s=3993:4025#L139">RemoteAddr</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>
RemoteAddr returns the remote network address.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetDeadline">func (*TCPConn) <a href="/src/net/net.go?s=4135:4180#L147">SetDeadline</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetKeepAlive">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=2902:2954#L104">SetKeepAlive</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetKeepAlive(keepalive <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetKeepAlive sets whether the operating system should send
keepalive messages on the connection.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetKeepAlivePeriod">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=3094:3153#L112">SetKeepAlivePeriod</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetKeepAlivePeriod(d <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetKeepAlivePeriod sets period between keep alives.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetLinger">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=2681:2723#L95">SetLinger</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetLinger(sec <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetLinger sets the behavior of Close on a connection which still
has data waiting to be sent or to be acknowledged.
</p>
<p>
If sec &lt; 0 (the default), the operating system finishes sending the
data in the background.
</p>
<p>
If sec == 0, the operating system discards any unsent or
unacknowledged data.
</p>
<p>
If sec &gt; 0, the data is sent in the background as with sec &lt; 0. On
some operating systems after sec seconds have elapsed any remaining
unsent data may be discarded.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetNoDelay">func (*TCPConn) <a href="/src/net/tcpsock_posix.go?s=3479:3527#L123">SetNoDelay</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetNoDelay(noDelay <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetNoDelay controls whether the operating system should delay
packet transmission in hopes of sending fewer packets (Nagle&#39;s
algorithm).  The default is true (no delay), meaning that data is
sent as soon as possible after a Write.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetReadBuffer">func (*TCPConn) <a href="/src/net/net.go?s=4748:4793#L172">SetReadBuffer</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetReadDeadline">func (*TCPConn) <a href="/src/net/net.go?s=4318:4367#L155">SetReadDeadline</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetWriteBuffer">func (*TCPConn) <a href="/src/net/net.go?s=4984:5030#L181">SetWriteBuffer</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="TCPConn.SetWriteDeadline">func (*TCPConn) <a href="/src/net/net.go?s=4511:4561#L163">SetWriteDeadline</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
				
			
				
				<h3 id="TCPConn.Write">func (*TCPConn) <a href="/src/net/net.go?s=3566:3609#L115">Write</a></h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
				
			
		
			
			
			<h2 id="TCPListener">type <a href="/src/net/tcpsock_posix.go?s=7230:7268#L214">TCPListener</a></h2>
			<pre>type TCPListener struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
TCPListener is a TCP network listener.  Clients should typically
use variables of type Listener instead of assuming TCP.
</p>


			

			

			
			
			

			
				
				<h3 id="ListenTCP">func <a href="/src/net/tcpsock_posix.go?s=9140:9204#L275">ListenTCP</a></h3>
				<pre>func ListenTCP(net <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#TCPAddr">TCPAddr</a>) (*<a href="#TCPListener">TCPListener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenTCP announces on the TCP address laddr and returns a TCP
listener.  Net must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.  If laddr has a
port of 0, ListenTCP will choose an available port.  The caller can
use the Addr method of TCPListener to retrieve the chosen address.
</p>

				
				
			

			
				
				<h3 id="TCPListener.Accept">func (*TCPListener) <a href="/src/net/tcpsock_posix.go?s=7684:7728#L233">Accept</a></h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) Accept() (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Accept implements the Accept method in the Listener interface; it
waits for the next call and returns a generic Conn.
</p>

				
				
				
			
				
				<h3 id="TCPListener.AcceptTCP">func (*TCPListener) <a href="/src/net/tcpsock_posix.go?s=7349:7400#L220">AcceptTCP</a></h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) AcceptTCP() (*<a href="#TCPConn">TCPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AcceptTCP accepts the next incoming call and returns the new
connection.
</p>

				
				
				
			
				
				<h3 id="TCPListener.Addr">func (*TCPListener) <a href="/src/net/tcpsock_posix.go?s=8084:8117#L251">Addr</a></h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) Addr() <a href="#Addr">Addr</a></pre>
				<p>
Addr returns the listener&#39;s network address, a *TCPAddr.
</p>

				
				
				
			
				
				<h3 id="TCPListener.Close">func (*TCPListener) <a href="/src/net/tcpsock_posix.go?s=7905:7940#L243">Close</a></h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Close stops listening on the TCP address.
Already Accepted connections are not closed.
</p>

				
				
				
			
				
				<h3 id="TCPListener.File">func (*TCPListener) <a href="/src/net/tcpsock_posix.go?s=8789:8841#L269">File</a></h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking
mode.  It is the caller&#39;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
</p>
<p>
The returned os.File&#39;s file descriptor is different from the
connection&#39;s.  Attempting to change properties of the original
using this duplicate may or may not have the desired effect.
</p>

				
				
				
			
				
				<h3 id="TCPListener.SetDeadline">func (*TCPListener) <a href="/src/net/tcpsock_posix.go?s=8248:8300#L255">SetDeadline</a></h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.
</p>

				
				
				
			
		
			
			
			<h2 id="UDPAddr">type <a href="/src/net/udpsock.go?s=228:314#L1">UDPAddr</a></h2>
			<pre>type UDPAddr struct {
        IP   <a href="#IP">IP</a>
        Port <a href="/pkg/builtin/#int">int</a>
        Zone <a href="/pkg/builtin/#string">string</a> <span class="comment">// IPv6 scoped addressing zone</span>
}</pre>
			<p>
UDPAddr represents the address of a UDP end point.
</p>


			

			

			
			
			

			
				
				<h3 id="ResolveUDPAddr">func <a href="/src/net/udpsock.go?s=1076:1131#L31">ResolveUDPAddr</a></h3>
				<pre>func ResolveUDPAddr(net, addr <a href="/pkg/builtin/#string">string</a>) (*<a href="#UDPAddr">UDPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ResolveUDPAddr parses addr as a UDP address of the form &#34;host:port&#34;
or &#34;[ipv6-host%zone]:port&#34; and resolves a pair of domain name and
port name on the network net, which must be &#34;udp&#34;, &#34;udp4&#34; or
&#34;udp6&#34;.  A literal address or host name for IPv6 must be enclosed
in square brackets, as in &#34;[::1]:80&#34;, &#34;[ipv6-host]:http&#34; or
&#34;[ipv6-host%zone]:80&#34;.
</p>

				
				
			

			
				
				<h3 id="UDPAddr.Network">func (*UDPAddr) <a href="/src/net/udpsock.go?s=370:404#L5">Network</a></h3>
				<pre>func (a *<a href="#UDPAddr">UDPAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Network returns the address&#39;s network name, &#34;udp&#34;.
</p>

				
				
				
			
				
				<h3 id="UDPAddr.String">func (*UDPAddr) <a href="/src/net/udpsock.go?s=423:456#L7">String</a></h3>
				<pre>func (a *<a href="#UDPAddr">UDPAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UDPConn">type <a href="/src/net/udpsock_posix.go?s=1127:1156#L40">UDPConn</a></h2>
			<pre>type UDPConn struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UDPConn is the implementation of the Conn and PacketConn interfaces
for UDP network connections.
</p>


			

			

			
			
			

			
				
				<h3 id="DialUDP">func <a href="/src/net/udpsock_posix.go?s=4811:4876#L155">DialUDP</a></h3>
				<pre>func DialUDP(net <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#UDPAddr">UDPAddr</a>) (*<a href="#UDPConn">UDPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
DialUDP connects to the remote address raddr on the network net,
which must be &#34;udp&#34;, &#34;udp4&#34;, or &#34;udp6&#34;.  If laddr is not nil, it is
used as the local address for the connection.
</p>

				
				
			
				
				<h3 id="ListenMulticastUDP">func <a href="/src/net/udpsock_posix.go?s=6575:6660#L202">ListenMulticastUDP</a></h3>
				<pre>func ListenMulticastUDP(net <a href="/pkg/builtin/#string">string</a>, ifi *<a href="#Interface">Interface</a>, gaddr *<a href="#UDPAddr">UDPAddr</a>) (*<a href="#UDPConn">UDPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenMulticastUDP listens for incoming multicast UDP packets
addressed to the group address gaddr on ifi, which specifies the
interface to join.  ListenMulticastUDP uses default multicast
interface if ifi is nil.
</p>

				
				
			
				
				<h3 id="ListenUDP">func <a href="/src/net/udpsock_posix.go?s=5886:5946#L182">ListenUDP</a></h3>
				<pre>func ListenUDP(net <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#UDPAddr">UDPAddr</a>) (*<a href="#UDPConn">UDPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenUDP listens for incoming UDP packets addressed to the local
address laddr.  Net must be &#34;udp&#34;, &#34;udp4&#34;, or &#34;udp6&#34;.  If laddr has
a port of 0, ListenUDP will choose an available port.
The LocalAddr method of the returned UDPConn can be used to
discover the port.  The returned connection&#39;s ReadFrom and WriteTo
methods can be used to receive and send UDP packets with per-packet
addressing.
</p>

				
				
			

			
				
				<h3 id="UDPConn.Close">func (*UDPConn) <a href="/src/net/net.go?s=3713:3741#L123">Close</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the connection.
</p>

				
				
				
			
				
				<h3 id="UDPConn.File">func (*UDPConn) <a href="/src/net/net.go?s=5510:5555#L195">File</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
File sets the underlying os.File to blocking mode and returns a copy.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
<p>
The returned os.File&#39;s file descriptor is different from the connection&#39;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.
</p>

				
				
				
			
				
				<h3 id="UDPConn.LocalAddr">func (*UDPConn) <a href="/src/net/net.go?s=3857:3888#L131">LocalAddr</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
				
			
				
				<h3 id="UDPConn.Read">func (*UDPConn) <a href="/src/net/net.go?s=3410:3452#L107">Read</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.ReadFrom">func (*UDPConn) <a href="/src/net/udpsock_posix.go?s=1995:2050#L68">ReadFrom</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom implements the PacketConn ReadFrom method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.ReadFromUDP">func (*UDPConn) <a href="/src/net/udpsock_posix.go?s=1547:1620#L53">ReadFromUDP</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadFromUDP(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UDPAddr">UDPAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFromUDP reads a UDP packet from c, copying the payload into b.
It returns the number of bytes copied into b and the return address
that was on the packet.
</p>
<p>
ReadFromUDP can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetReadDeadline.
</p>

				
				
				
			
				
				<h3 id="UDPConn.ReadMsgUDP">func (*UDPConn) <a href="/src/net/udpsock_posix.go?s=2451:2541#L81">ReadMsgUDP</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadMsgUDP(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UDPAddr">UDPAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadMsgUDP reads a packet from c, copying the payload into b and
the associated out-of-band data into oob.  It returns the number
of bytes copied into b, the number of bytes copied into oob, the
flags that were set on the packet and the source address of the
packet.
</p>

				
				
				
			
				
				<h3 id="UDPConn.RemoteAddr">func (*UDPConn) <a href="/src/net/net.go?s=3993:4025#L139">RemoteAddr</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>
RemoteAddr returns the remote network address.
</p>

				
				
				
			
				
				<h3 id="UDPConn.SetDeadline">func (*UDPConn) <a href="/src/net/net.go?s=4135:4180#L147">SetDeadline</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.SetReadBuffer">func (*UDPConn) <a href="/src/net/net.go?s=4748:4793#L172">SetReadBuffer</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="UDPConn.SetReadDeadline">func (*UDPConn) <a href="/src/net/net.go?s=4318:4367#L155">SetReadDeadline</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.SetWriteBuffer">func (*UDPConn) <a href="/src/net/net.go?s=4984:5030#L181">SetWriteBuffer</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="UDPConn.SetWriteDeadline">func (*UDPConn) <a href="/src/net/net.go?s=4511:4561#L163">SetWriteDeadline</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.Write">func (*UDPConn) <a href="/src/net/net.go?s=3566:3609#L115">Write</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.WriteMsgUDP">func (*UDPConn) <a href="/src/net/udpsock_posix.go?s=4135:4219#L135">WriteMsgUDP</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteMsgUDP(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UDPAddr">UDPAddr</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteMsgUDP writes a packet to addr via c, copying the payload from
b and the associated out-of-band data from oob.  It returns the
number of payload and out-of-band bytes written.
</p>

				
				
				
			
				
				<h3 id="UDPConn.WriteTo">func (*UDPConn) <a href="/src/net/udpsock_posix.go?s=3708:3767#L121">WriteTo</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo implements the PacketConn WriteTo method.
</p>

				
				
				
			
				
				<h3 id="UDPConn.WriteToUDP">func (*UDPConn) <a href="/src/net/udpsock_posix.go?s=3203:3269#L103">WriteToUDP</a></h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteToUDP(b []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UDPAddr">UDPAddr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteToUDP writes a UDP packet to addr via c, copying the payload
from b.
</p>
<p>
WriteToUDP can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetWriteDeadline.  On packet-oriented connections, write timeouts
are rare.
</p>

				
				
				
			
		
			
			
			<h2 id="UnixAddr">type <a href="/src/net/unixsock.go?s=244:294#L1">UnixAddr</a></h2>
			<pre>type UnixAddr struct {
        Name <a href="/pkg/builtin/#string">string</a>
        Net  <a href="/pkg/builtin/#string">string</a>
}</pre>
			<p>
UnixAddr represents the address of a Unix domain socket end point.
</p>


			

			

			
			
			

			
				
				<h3 id="ResolveUnixAddr">func <a href="/src/net/unixsock.go?s=751:808#L26">ResolveUnixAddr</a></h3>
				<pre>func ResolveUnixAddr(net, addr <a href="/pkg/builtin/#string">string</a>) (*<a href="#UnixAddr">UnixAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ResolveUnixAddr parses addr as a Unix domain socket address.
The string net gives the network name, &#34;unix&#34;, &#34;unixgram&#34; or
&#34;unixpacket&#34;.
</p>

				
				
			

			
				
				<h3 id="UnixAddr.Network">func (*UnixAddr) <a href="/src/net/unixsock.go?s=382:417#L5">Network</a></h3>
				<pre>func (a *<a href="#UnixAddr">UnixAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Network returns the address&#39;s network name, &#34;unix&#34;, &#34;unixgram&#34; or
&#34;unixpacket&#34;.
</p>

				
				
				
			
				
				<h3 id="UnixAddr.String">func (*UnixAddr) <a href="/src/net/unixsock.go?s=437:471#L9">String</a></h3>
				<pre>func (a *<a href="#UnixAddr">UnixAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UnixConn">type <a href="/src/net/unixsock_posix.go?s=2248:2278#L93">UnixConn</a></h2>
			<pre>type UnixConn struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UnixConn is an implementation of the Conn interface for connections
to Unix domain sockets.
</p>


			

			

			
			
			

			
				
				<h3 id="DialUnix">func <a href="/src/net/unixsock_posix.go?s=6286:6354#L223">DialUnix</a></h3>
				<pre>func DialUnix(net <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#UnixAddr">UnixAddr</a>) (*<a href="#UnixConn">UnixConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
DialUnix connects to the remote address raddr on the network net,
which must be &#34;unix&#34;, &#34;unixgram&#34; or &#34;unixpacket&#34;.  If laddr is not
nil, it is used as the local address for the connection.
</p>

				
				
			
				
				<h3 id="ListenUnixgram">func <a href="/src/net/unixsock_posix.go?s=10067:10134#L338">ListenUnixgram</a></h3>
				<pre>func ListenUnixgram(net <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#UnixAddr">UnixAddr</a>) (*<a href="#UnixConn">UnixConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenUnixgram listens for incoming Unix datagram packets addressed
to the local address laddr.  The network net must be &#34;unixgram&#34;.
The returned connection&#39;s ReadFrom and WriteTo methods can be used
to receive and send packets with per-packet addressing.
</p>

				
				
			

			
				
				<h3 id="UnixConn.Close">func (*UnixConn) <a href="/src/net/net.go?s=3713:3741#L123">Close</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the connection.
</p>

				
				
				
			
				
				<h3 id="UnixConn.CloseRead">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=5757:5793#L204">CloseRead</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) CloseRead() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CloseRead shuts down the reading side of the Unix domain connection.
Most callers should just use Close.
</p>

				
				
				
			
				
				<h3 id="UnixConn.CloseWrite">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=5977:6014#L213">CloseWrite</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) CloseWrite() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
CloseWrite shuts down the writing side of the Unix domain connection.
Most callers should just use Close.
</p>

				
				
				
			
				
				<h3 id="UnixConn.File">func (*UnixConn) <a href="/src/net/net.go?s=5510:5555#L195">File</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
File sets the underlying os.File to blocking mode and returns a copy.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>
<p>
The returned os.File&#39;s file descriptor is different from the connection&#39;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.
</p>

				
				
				
			
				
				<h3 id="UnixConn.LocalAddr">func (*UnixConn) <a href="/src/net/net.go?s=3857:3888#L131">LocalAddr</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
				
			
				
				<h3 id="UnixConn.Read">func (*UnixConn) <a href="/src/net/net.go?s=3410:3452#L107">Read</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.ReadFrom">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=3037:3093#L121">ReadFrom</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom implements the PacketConn ReadFrom method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.ReadFromUnix">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=2662:2738#L106">ReadFromUnix</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) ReadFromUnix(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UnixAddr">UnixAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFromUnix reads a packet from c, copying the payload into b.  It
returns the number of bytes copied into b and the source address of
the packet.
</p>
<p>
ReadFromUnix can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetReadDeadline.
</p>

				
				
				
			
				
				<h3 id="UnixConn.ReadMsgUnix">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=3494:3587#L133">ReadMsgUnix</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) ReadMsgUnix(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UnixAddr">UnixAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadMsgUnix reads a packet from c, copying the payload into b and
the associated out-of-band data into oob.  It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the packet, and the source address of the packet.
</p>

				
				
				
			
				
				<h3 id="UnixConn.RemoteAddr">func (*UnixConn) <a href="/src/net/net.go?s=3993:4025#L139">RemoteAddr</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>
RemoteAddr returns the remote network address.
</p>

				
				
				
			
				
				<h3 id="UnixConn.SetDeadline">func (*UnixConn) <a href="/src/net/net.go?s=4135:4180#L147">SetDeadline</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.SetReadBuffer">func (*UnixConn) <a href="/src/net/net.go?s=4748:4793#L172">SetReadBuffer</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="UnixConn.SetReadDeadline">func (*UnixConn) <a href="/src/net/net.go?s=4318:4367#L155">SetReadDeadline</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.SetWriteBuffer">func (*UnixConn) <a href="/src/net/net.go?s=4984:5030#L181">SetWriteBuffer</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
				
			
				
				<h3 id="UnixConn.SetWriteDeadline">func (*UnixConn) <a href="/src/net/net.go?s=4511:4561#L163">SetWriteDeadline</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.Write">func (*UnixConn) <a href="/src/net/net.go?s=3566:3609#L115">Write</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.WriteMsgUnix">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=5130:5217#L185">WriteMsgUnix</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) WriteMsgUnix(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UnixAddr">UnixAddr</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteMsgUnix writes a packet to addr via c, copying the payload
from b and the associated out-of-band data from oob.  It returns
the number of payload and out-of-band bytes written.
</p>

				
				
				
			
				
				<h3 id="UnixConn.WriteTo">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=4693:4759#L171">WriteTo</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo implements the PacketConn WriteTo method.
</p>

				
				
				
			
				
				<h3 id="UnixConn.WriteToUnix">func (*UnixConn) <a href="/src/net/unixsock_posix.go?s=4144:4219#L153">WriteToUnix</a></h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) WriteToUnix(b []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UnixAddr">UnixAddr</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteToUnix writes a packet to addr via c, copying the payload from b.
</p>
<p>
WriteToUnix can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetWriteDeadline.  On packet-oriented connections, write timeouts
are rare.
</p>

				
				
				
			
		
			
			
			<h2 id="UnixListener">type <a href="/src/net/unixsock_posix.go?s=6989:7043#L243">UnixListener</a></h2>
			<pre>type UnixListener struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UnixListener is a Unix domain socket listener.  Clients should
typically use variables of type Listener instead of assuming Unix
domain sockets.
</p>


			

			

			
			
			

			
				
				<h3 id="ListenUnix">func <a href="/src/net/unixsock_posix.go?s=7182:7249#L250">ListenUnix</a></h3>
				<pre>func ListenUnix(net <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#UnixAddr">UnixAddr</a>) (*<a href="#UnixListener">UnixListener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ListenUnix announces on the Unix domain socket laddr and returns a
Unix listener.  The network net must be &#34;unix&#34; or &#34;unixpacket&#34;.
</p>

				
				
			

			
				
				<h3 id="UnixListener.Accept">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=8134:8185#L282">Accept</a></h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) Accept() (c <a href="#Conn">Conn</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Accept implements the Accept method in the Listener interface; it
waits for the next call and returns a generic Conn.
</p>

				
				
				
			
				
				<h3 id="UnixListener.AcceptUnix">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=7787:7841#L268">AcceptUnix</a></h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) AcceptUnix() (*<a href="#UnixConn">UnixConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
AcceptUnix accepts the next incoming call and returns the new
connection.
</p>

				
				
				
			
				
				<h3 id="UnixListener.Addr">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=9009:9043#L314">Addr</a></h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) Addr() <a href="#Addr">Addr</a></pre>
				<p>
Addr returns the listener&#39;s network address.
</p>

				
				
				
			
				
				<h3 id="UnixListener.Close">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=8367:8403#L292">Close</a></h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Close stops listening on the Unix address.  Already accepted
connections are not closed.
</p>

				
				
				
			
				
				<h3 id="UnixListener.File">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=9722:9775#L332">File</a></h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking
mode.  It is the caller&#39;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
</p>
<p>
The returned os.File&#39;s file descriptor is different from the
connection&#39;s.  Attempting to change properties of the original
using this duplicate may or may not have the desired effect.
</p>

				
				
				
			
				
				<h3 id="UnixListener.SetDeadline">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=9174:9233#L318">SetDeadline</a></h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.
</p>

				
				
				
			
		
			
			
			<h2 id="UnknownNetworkError">type <a href="/src/net/net.go?s=9998:10029#L362">UnknownNetworkError</a></h2>
			<pre>type UnknownNetworkError <a href="/pkg/builtin/#string">string</a></pre>
			

			

			

			
			
			

			

			
				
				<h3 id="UnknownNetworkError.Error">func (UnknownNetworkError) <a href="/src/net/net.go?s=10031:10074#L364">Error</a></h3>
				<pre>func (e <a href="#UnknownNetworkError">UnknownNetworkError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="UnknownNetworkError.Temporary">func (UnknownNetworkError) <a href="/src/net/net.go?s=10119:10164#L365">Temporary</a></h3>
				<pre>func (e <a href="#UnknownNetworkError">UnknownNetworkError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="UnknownNetworkError.Timeout">func (UnknownNetworkError) <a href="/src/net/net.go?s=10182:10225#L366">Timeout</a></h3>
				<pre>func (e <a href="#UnknownNetworkError">UnknownNetworkError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="/src/net/iprawsock_posix.go?s=283:850#L4">&#x261e;</a> On every POSIX platform, reads from the &#34;ip4&#34; network
using the ReadFrom or ReadFromIP method might not return a complete
IPv4 packet, including its header, even if there is space
available. This can occur even in cases where Read or ReadMsgIP
could return a complete packet. For this reason, it is recommended
that you do not uses these methods if it is important to receive a
full packet.

The Go 1 compatibility guidelines make it impossible for us to
change the behavior of these methods; use Read or ReadMsgIP
instead.
</li>
			
			<li><a href="/src/net/tcpsock_posix.go?s=295:596#L6">&#x261e;</a> On OpenBSD, listening on the &#34;tcp&#34; network does not listen for
both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic
will not be routed to an IPv6 socket - two separate sockets are required
if both AFs are to be supported. See inet6(4) on OpenBSD for details.
</li>
			
			</ul>
		
	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="http/">http</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package http provides HTTP client and server implementations.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http/cgi/">cgi</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http/cookiejar/">cookiejar</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http/fcgi/">fcgi</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package fcgi implements the FastCGI protocol.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http/httptest/">httptest</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package httptest provides utilities for HTTP testing.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http/httputil/">httputil</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http/pprof/">pprof</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="mail/">mail</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package mail implements parsing of mail messages.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="rpc/">rpc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package rpc provides access to the exported methods of an object across a network or other I/O connection.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="rpc/jsonrpc/">jsonrpc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package jsonrpc implements a JSON-RPC ClientCodec and ServerCodec for the rpc package.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="smtp/">smtp</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="textproto/">textproto</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="url/">url</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package url parses URLs and implements query escaping.</td>
			</tr>
		
	
	</table>

	



<div id="footer">
Build version go1.4.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="/lib/godoc/jquery.treeview.js"></script>
<script type="text/javascript" src="/lib/godoc/jquery.treeview.edit.js"></script>


<script type="text/javascript" src="/lib/godoc/playground.js"></script>

<script type="text/javascript" src="/lib/godoc/godocs.js"></script>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>

